---
phase: 01-target-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Mordecai.Data/Migrations/[timestamp]_AddActiveSpawnCurrentRoomIdIndex.cs
  - Mordecai.Web/Services/TargetResolutionService.cs
  - Mordecai.Web.Tests/TargetResolutionServiceTests.cs
autonomous: true

must_haves:
  truths:
    - "attack goblin command finds ActiveSpawn NPC in player's room"
    - "Partial name prefix 'gob' matches 'goblin' (case-insensitive)"
    - "Multiple matching NPCs return disambiguation list"
    - "'goblin 2' selects second matching NPC"
    - "TargetResolutionService queries real ActiveSpawn entities"
  artifacts:
    - path: "Mordecai.Web/Services/TargetResolutionService.cs"
      provides: "NPC target resolution with disambiguation"
      contains: "FindNpcInRoomAsync"
    - path: "Mordecai.Data/Migrations/*_AddActiveSpawnCurrentRoomIdIndex.cs"
      provides: "Database index for efficient room queries"
      contains: "HasIndex"
    - path: "Mordecai.Web.Tests/TargetResolutionServiceTests.cs"
      provides: "Test coverage for target resolution"
      contains: "FindNpcInRoomAsync"
  key_links:
    - from: "Mordecai.Web/Services/TargetResolutionService.cs"
      to: "ApplicationDbContext.ActiveSpawns"
      via: "EF Core query with Include(NpcTemplate)"
      pattern: "_context\\.ActiveSpawns.*Include.*NpcTemplate"
    - from: "TargetResolutionService"
      to: "NpcTemplate.Name"
      via: "ToLower().StartsWith() for prefix matching"
      pattern: "ToLower\\(\\)\\.StartsWith"
---

<objective>
Implement real NPC target resolution so players can target ActiveSpawn NPCs in their room using natural language commands like "attack goblin".

Purpose: This enables combat commands to resolve targets from actual game entities instead of simulated data, which is the foundation for all combat features.

Output: Working TargetResolutionService that queries ActiveSpawn entities by room, handles prefix matching, and implements disambiguation for multiple matches.
</objective>

<execution_context>
@C:\Users\rocky\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\rocky\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-target-resolution/01-CONTEXT.md
@.planning/phases/01-target-resolution/01-RESEARCH.md
@Mordecai.Web/Services/TargetResolutionService.cs
@Mordecai.Game/Entities/SpawnerEntities.cs
@Mordecai.Web/Data/ApplicationDbContext.cs
@.planning/codebase/TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CurrentRoomId index and result types</name>
  <files>
    - Mordecai.Data/Migrations/[timestamp]_AddActiveSpawnCurrentRoomIdIndex.cs
    - Mordecai.Web/Services/TargetResolutionService.cs
  </files>
  <action>
Create EF Core migration to add index on ActiveSpawn.CurrentRoomId for efficient room-scoped queries:

```bash
dotnet ef migrations add AddActiveSpawnCurrentRoomIdIndex --project Mordecai.Data --startup-project Mordecai.Web
```

Then in ApplicationDbContext.cs, add to the ActiveSpawn configuration:
```csharp
entity.HasIndex(asp => asp.CurrentRoomId);
```

Add discriminated result types to TargetResolutionService.cs (before the class definition):

```csharp
/// <summary>
/// Result of NPC target resolution
/// </summary>
public abstract record NpcResolutionResult;

/// <summary>
/// Single NPC found matching the search term
/// </summary>
public sealed record NpcFound(CommunicationTarget Target) : NpcResolutionResult;

/// <summary>
/// No NPC found matching the search term
/// </summary>
public sealed record NpcNotFound(string SearchTerm) : NpcResolutionResult;

/// <summary>
/// Multiple NPCs match - disambiguation required
/// </summary>
public sealed record MultipleNpcsFound(
    string SearchTerm,
    IReadOnlyList<CommunicationTarget> Matches
) : NpcResolutionResult;
```

Run migration to update database:
```bash
dotnet ef database update --project Mordecai.Data --startup-project Mordecai.Web
```
  </action>
  <verify>
1. Migration file exists with HasIndex for CurrentRoomId
2. `dotnet build` succeeds
3. Result types compile without errors
  </verify>
  <done>
Index migration created and applied. NpcResolutionResult discriminated union types exist in TargetResolutionService.cs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement real NPC queries with disambiguation</name>
  <files>
    - Mordecai.Web/Services/TargetResolutionService.cs
  </files>
  <action>
Replace the simulated NPC lookup in TargetResolutionService with real ActiveSpawn queries.

**Add new method `FindNpcInRoomAsync`:**

```csharp
/// <summary>
/// Finds NPC(s) matching the search term in the specified room.
/// Supports prefix matching (case-insensitive) and numeric disambiguation suffix.
/// </summary>
/// <param name="searchInput">Target string (e.g., "goblin", "gob", "goblin 2")</param>
/// <param name="roomId">Room ID to search within</param>
/// <returns>Resolution result indicating found, not found, or multiple matches</returns>
public async Task<NpcResolutionResult> FindNpcInRoomAsync(string searchInput, int roomId)
```

Implementation requirements per CONTEXT.md:
1. Parse input for numeric suffix: split on space, check if last token is numeric
   - "goblin 2" -> searchTerm="goblin", index=2
   - "goblin warrior" -> searchTerm="goblin warrior", index=null
   - "goblin warrior 2" -> searchTerm="goblin warrior", index=2

2. Query ActiveSpawns with filters:
   - `IsActive == true` (always)
   - `CurrentRoomId == roomId`
   - `NpcTemplate.Name.ToLower().StartsWith(searchTerm.ToLower())` (prefix match)
   - Include NpcTemplate for name access
   - Use AsNoTracking for read-only queries

3. Handle results:
   - 0 matches: return `NpcNotFound(searchTerm)`
   - 1 match: return `NpcFound(target)` converting ActiveSpawn to CommunicationTarget
   - N matches with index: validate index 1-N, return NpcFound for selected or NpcNotFound if invalid index
   - N matches without index: return `MultipleNpcsFound(searchTerm, matches)`

4. Convert ActiveSpawn to CommunicationTarget:
   - Id = ActiveSpawn.NpcId (Guid)
   - Name = NpcTemplate.Name
   - Type = TargetType.Npc
   - IsOnline = true (NPCs are always "online")

**Update `FindTargetInRoomAsync`:**
Replace the simulated NPC section (lines ~63-77) with a call to the new method:

```csharp
// Try NPC match
var npcResult = await FindNpcInRoomAsync(searchName, roomId);
if (npcResult is NpcFound found)
{
    _logger.LogDebug("Found NPC {TargetName} in room {RoomId}", found.Target.Name, roomId);
    return found.Target;
}
// Note: For now, multiple matches returns null (caller should use FindNpcInRoomAsync directly for disambiguation)
```

**Remove** the `GetSimulatedTargetsInRoom` method (it will no longer be needed).

**Update `GetAllTargetsInRoomAsync`:**
Replace simulated NPCs section with real query:

```csharp
// Get all active NPCs in the room
var npcsInRoom = await _context.ActiveSpawns
    .AsNoTracking()
    .Where(asp => asp.IsActive && asp.CurrentRoomId == roomId)
    .Include(asp => asp.NpcTemplate)
    .Select(asp => new CommunicationTarget(
        asp.NpcId,
        asp.NpcTemplate.Name,
        TargetType.Npc,
        true))
    .ToListAsync();

targets.AddRange(npcsInRoom);
```
  </action>
  <verify>
1. `dotnet build` succeeds
2. Code review: GetSimulatedTargetsInRoom is removed
3. Code review: FindNpcInRoomAsync queries real ActiveSpawns with IsActive filter
4. Code review: Prefix matching uses ToLower().StartsWith()
5. Code review: Numeric suffix parsing handles "goblin 2" and "goblin warrior 2"
  </verify>
  <done>
TargetResolutionService queries real ActiveSpawn entities. Simulated data methods removed. Disambiguation logic handles numeric suffix syntax per CONTEXT.md decisions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for target resolution</name>
  <files>
    - Mordecai.Web.Tests/TargetResolutionServiceTests.cs
  </files>
  <action>
Create new test file following project patterns (see .planning/codebase/TESTING.md).

Test scenarios (using in-memory database, AAA pattern):

**Setup helper:**
```csharp
private static async Task<(int RoomId, List<Guid> NpcIds)> SeedNpcScenarioAsync(
    IDbContextFactory<ApplicationDbContext> factory,
    int npcCount,
    string npcNamePrefix = "goblin",
    CancellationToken cancellationToken = default)
```
Creates Zone, Room, NpcTemplate, SpawnerTemplate, SpawnerInstance, and ActiveSpawn entities.

**Test cases:**

1. `FindNpcInRoomAsync_ReturnsNpcFound_WhenSingleMatch`
   - Seed one "goblin" in room
   - Search "goblin" -> NpcFound
   - Search "gob" (prefix) -> NpcFound

2. `FindNpcInRoomAsync_ReturnsNpcNotFound_WhenNoMatch`
   - Seed one "goblin" in room
   - Search "dragon" -> NpcNotFound

3. `FindNpcInRoomAsync_ReturnsMultipleNpcsFound_WhenAmbiguous`
   - Seed two goblins with same template in room
   - Search "goblin" -> MultipleNpcsFound with 2 matches

4. `FindNpcInRoomAsync_ResolvesDisambiguation_WithNumericSuffix`
   - Seed two goblins in room
   - Search "goblin 1" -> NpcFound (first)
   - Search "goblin 2" -> NpcFound (second)
   - Search "goblin 3" -> NpcNotFound (invalid index)

5. `FindNpcInRoomAsync_IsCaseInsensitive`
   - Seed "Goblin Warrior" in room
   - Search "GOBLIN" -> NpcFound
   - Search "goblin w" -> NpcFound

6. `FindNpcInRoomAsync_IgnoresInactiveSpawns`
   - Seed one active and one inactive "goblin"
   - Search "goblin" -> NpcFound (only the active one)

7. `FindNpcInRoomAsync_IgnoresNpcsInOtherRooms`
   - Seed "goblin" in room 1, "orc" in room 2
   - Search "goblin" in room 2 -> NpcNotFound
   - Search "orc" in room 1 -> NpcNotFound

8. `GetAllTargetsInRoomAsync_ReturnsRealNpcs`
   - Seed two NPCs in room
   - GetAllTargetsInRoomAsync returns both
  </action>
  <verify>
1. `dotnet test Mordecai.Web.Tests` - all tests pass
2. At least 8 test methods exist in TargetResolutionServiceTests.cs
3. Tests use in-memory database with unique names per test
  </verify>
  <done>
TargetResolutionServiceTests.cs exists with comprehensive coverage of target resolution including prefix matching, disambiguation, case-insensitivity, and room isolation. All tests pass.
  </done>
</task>

</tasks>

<verification>
Run full test suite and verify target resolution works end-to-end:

```bash
# All tests pass
dotnet test Mordecai.Web.Tests

# Project builds without warnings
dotnet build --warnaserror

# Migration is applied (no pending migrations)
dotnet ef migrations list --project Mordecai.Data --startup-project Mordecai.Web
```

Manual verification (if Aspire environment available):
1. Start application: `dotnet run --project Mordecai.AppHost`
2. Spawn test NPCs via admin tools or database seed
3. Target NPC with partial name - should resolve
4. Target with ambiguous name - should prompt for disambiguation
</verification>

<success_criteria>
1. [x] TGT-01: TargetResolutionService queries ActiveSpawn entities (not simulated data)
2. [x] TGT-02: ActiveSpawn.CurrentRoomId has database index for efficient queries
3. [x] TGT-03: "attack goblin" resolves to correct ActiveSpawn in player's room
4. [x] Case-insensitive prefix matching works ("gob" matches "goblin")
5. [x] Multiple matches return disambiguation list
6. [x] "goblin 2" syntax selects second match
7. [x] All tests pass
8. [x] No simulated/hardcoded NPC data remains in TargetResolutionService
</success_criteria>

<output>
After completion, create `.planning/phases/01-target-resolution/01-01-SUMMARY.md`
</output>
