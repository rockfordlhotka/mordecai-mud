@page "/play/{characterId:guid}"
@page "/play"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using System
@using System.Security.Claims
@using Mordecai.Web.Services
@using Mordecai.Messaging.Services
@using Mordecai.Messaging.Messages
@using Mordecai.Game.Entities
@using Mordecai.Game.Services
@using Mordecai.Web.Data
@using Microsoft.EntityFrameworkCore
@using System.Threading
@using System.Linq
@attribute [Authorize]
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject CharacterMessageBroadcastService MessageBroadcastService
@inject IGameMessagePublisher MessagePublisher
@inject GameActionService GameActionService
@inject ICharacterService CharacterService
@inject IWorldService WorldService
@inject SkillService SkillService
@inject IDoorInteractionService DoorInteractionService
@inject IEquipmentService EquipmentService
@inject IItemTemplateService ItemTemplateService
@inject ISpawnerService SpawnerService
@inject ICombatService CombatService
@inject ApplicationDbContext DbContext
@inject IJSRuntime JSRuntime
@inject ILoggerFactory LoggerFactory
@inject ICurrencyService CurrencyService
@implements IDisposable

<PageTitle>Play Mordecai MUD</PageTitle>

<!-- Override the normal layout for the play page -->
<div class="play-page-container">
    <!-- Exit button and header -->
    <div class="play-page-header bg-dark text-white p-2 d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
            <button class="btn btn-outline-light btn-sm me-3" @onclick="ExitGame">
                <i class="oi oi-arrow-left me-1"></i>Exit Game
            </button>
            <h6 class="mb-0">Mordecai MUD - @characterName</h6>
        </div>
        <div class="small">
            @if (currentRoom != null)
            {
                <span>@currentRoom.Zone.Name - @currentRoom.Name</span>
            }
            else if (currentRoomId.HasValue)
            {
                <span>Room ID: @currentRoomId</span>
            }

            @if (isCurrentUserAdmin)
            {
                <span class="badge bg-warning text-dark ms-2">Admin</span>
            }
        </div>
    </div>

    <div class="play-page-content">
        <!-- Character Status Panel -->
        <div class="character-panel d-none d-md-block">
            <div class="character-status h-100 bg-dark text-white p-3">
                <div class="character-header mb-3">
                    <h5 class="text-success mb-1">@characterName</h5>
                    <small class="text-muted">@currentUserName</small>
                </div>

                <!-- Location Info -->
                @if (currentRoom != null)
                {
                    <div class="location-info mb-3">
                        <h6 class="text-info mb-1">Location</h6>
                        <div class="small">
                            <div>@currentRoom.Zone.Name</div>
                            <div>@currentRoom.Name</div>
                            <div class="text-muted">(@currentRoom.X, @currentRoom.Y, @currentRoom.Z)</div>
                        </div>
                    </div>
                }
                else if (currentRoomId.HasValue)
                {
                    <div class="location-info mb-3">
                        <h6 class="text-info mb-1">Location</h6>
                        <div class="small text-muted">Room ID: @currentRoomId</div>
                    </div>
                }

                <!-- Character Stats -->
                <div class="character-stats mb-3">
                    <h6 class="text-warning mb-2">Vitals</h6>

                    <!-- FAT (Fatigue) - Using HealthBar component -->
                    <div class="vital-bar mb-2">
                        <div class="d-flex justify-content-between small mb-1">
                            <span>FAT</span>
                            <span>@currentFat / @maxFat</span>
                        </div>
                        <Mordecai.Web.Components.HealthBar 
                            Current="@currentFat" 
                            Max="@maxFat" 
                            PendingDamage="@(pendingFat > 0 ? pendingFat : 0)"
                            PendingHealing="@(pendingFat < 0 ? -pendingFat : 0)"
                            Height="10" />
                    </div>

                    <!-- VIT (Vitality/Health) - Using HealthBar component -->
                    <div class="vital-bar mb-2">
                        <div class="d-flex justify-content-between small mb-1">
                            <span>VIT</span>
                            <span>@currentVit / @maxVit</span>
                        </div>
                        <Mordecai.Web.Components.HealthBar 
                            Current="@currentVit" 
                            Max="@maxVit" 
                            PendingDamage="@(pendingVit > 0 ? pendingVit : 0)"
                            PendingHealing="@(pendingVit < 0 ? -pendingVit : 0)"
                            Height="10" />
                    </div>
                    
                    <!-- Combat Status Indicators -->
                    <Mordecai.Web.Components.CombatStatusIndicators 
                        IsInCombat="@isInCombat"
                        IsParryMode="@isParryMode"
                        CurrentFatigue="@currentFat"
                        CurrentVitality="@currentVit"
                        MaxVitality="@maxVit"
                        IsFleeing="@isFleeing"
                        PendingDamage="@(Math.Max(0, pendingFat) + Math.Max(0, pendingVit))" />
                </div>

                <!-- Combat Panel -->
                <Mordecai.Web.Components.CombatPanel 
                    IsInCombat="@isInCombat"
                    CombatLog="@combatLog"
                    MaxLines="18" />

                <!-- Active Effects -->
                <div class="active-effects">
                    <h6 class="text-primary mb-2">Active Effects</h6>
                    <div class="effects-list">
                        @if (activeEffects.Any())
                        {
                            @foreach (var effect in activeEffects)
                            {
                                <div class="effect-item small mb-1 p-1 bg-secondary rounded">
                                    <div class="fw-bold">@effect.Name</div>
                                    @if (!string.IsNullOrEmpty(effect.Description))
                                    {
                                        <div class="text-muted">@effect.Description</div>
                                    }
                                    @if (effect.Duration.HasValue)
                                    {
                                        <div class="text-warning">@effect.Duration.Value.TotalSeconds.ToString("F0")s</div>
                                    }
                                </div>
                            }
                        }
                        else
                        {
                            <div class="small text-muted">No active effects</div>
                        }
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Game Area -->
        <div class="game-area">
            <div class="game-container h-100 d-flex flex-column">
                <!-- Mobile Header (visible on small screens) -->
                <div class="game-header bg-dark text-white p-2 d-md-none flex-shrink-0">
                    <h6 class="m-0">@characterName (@currentUserName)</h6>
                    @if (currentRoom != null)
                    {
                        <small class="text-muted">@currentRoom.Zone.Name - @currentRoom.Name</small>
                    }
                </div>
                
                <!-- Game Output Area -->
                <div class="game-output-container flex-grow-1 position-relative" style="min-height: 0;">
                    <div class="game-output h-100 p-3 bg-black text-light overflow-auto" 
                         style="font-family: 'Courier New', monospace; font-size: 14px;" 
                         @ref="gameOutputElement">
                        @if (gameMessages.Any())
                        {
                            @foreach (var message in gameMessages)
                            {
                                <div class="game-message mb-1">@((MarkupString)message)</div>
                            }
                        }
                        else
                        {
                            <div class="welcome-message">
                                <p class="text-success">Welcome to Mordecai MUD!</p>
                                <p>A skill-based, real-time text adventure where your actions shape your character.</p>
                                <p class="text-info">Getting Started:</p>
                                <ul>
                                    <li>Type <span class="text-warning">'look'</span> to examine your surroundings</li>
                                    <li>Type <span class="text-warning">'look [direction]'</span> to look in a specific direction (e.g., 'look north')</li>
                                    <li>Type <span class="text-warning">'search'</span> to search for hidden things using your awareness</li>
                                    <li>Type <span class="text-warning">'skills'</span> to view your character's skills and progress</li>
                                    <li>Type <span class="text-warning">'help'</span> to see available commands</li>
                                    <li>Type <span class="text-warning">'who'</span> to see other players online</li>
                                    <li>Type <span class="text-warning">'say [message]'</span> to talk to others in the room</li>
                                </ul>
                                <p class="text-muted">Your character begins their journey here...</p>
                            </div>
                        }
                    </div>
                </div>
                
                <!-- Game Input Area -->
                <div class="game-input bg-secondary p-2 flex-shrink-0">
                    <div class="input-group">
                        <span class="input-group-text bg-dark text-light">&gt;</span>
                        <input @bind="currentCommand" @bind:event="oninput" @onkeydown="OnKeyDown" type="text" 
                               class="form-control bg-dark text-light border-secondary" 
                               placeholder="Enter command..." 
                               @ref="commandInput" />
                        <button class="btn btn-outline-light" @onclick="SendCommand" disabled="@isProcessing">
                            @if (isProcessing)
                            {
                                <span class="spinner-border spinner-border-sm me-1"></span>
                            }
                            Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] public Guid? characterId { get; set; }
    private string currentUserName = "Adventurer";
    private string characterName = "Unknown";
    private string currentUserId = string.Empty;
    private bool isCurrentUserAdmin = false;
    private string currentCommand = string.Empty;
    private bool isProcessing = false;
    private ElementReference commandInput;
    private ElementReference gameOutputElement;
    private List<string> gameMessages = new();
    private List<string> commandHistory = new();
    private int historyIndex = -1;
    private int? currentRoomId = null;
    private Room? currentRoom = null;
    private bool isSubscribed = false;
    private Task? _healthRefreshTask;
    private CancellationTokenSource? _healthRefreshCts;
    private static readonly TimeSpan HealthRefreshInterval = TimeSpan.FromSeconds(3);
    private PendingItemSelection? pendingSelection;

    // Character vital stats - now loads from actual character data
    private int currentFat = 0;
    private int maxFat = 0;
    private int pendingFat = 0;
    private int currentVit = 0;
    private int maxVit = 0;
    private int pendingVit = 0;

    // Combat state
    private bool isInCombat = false;
    private bool isParryMode = false;
    private bool isFleeing = false;
    private Guid? combatSessionId = null;
    private List<Mordecai.Web.Components.CombatPanel.CombatLogEntry> combatLog = new();

    // Active effects (placeholder - should come from your character service)
    private List<ActiveEffect> activeEffects = new();

    // Helper class for active effects
    private class ActiveEffect
    {
        public string Name { get; set; } = string.Empty;
        public string? Description { get; set; }
        public TimeSpan? Duration { get; set; }
        public string EffectType { get; set; } = string.Empty;
    }

    private ILogger? _logger;

    protected override async Task OnInitializedAsync()
    {
        _logger ??= LoggerFactory?.CreateLogger("Play.razor");
        _logger?.LogDebug("Play.OnInitializedAsync start - characterId={CharacterId}", characterId);
        // If no character ID provided, redirect to character selection
        if (characterId == null || characterId == Guid.Empty)
        {
            NavigationManager.NavigateTo("/characters");
            return;
        }

        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        currentUserName = user?.Identity?.Name ?? "Adventurer";
        currentUserId = user?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? string.Empty;
        isCurrentUserAdmin = user?.IsInRole("Admin") ?? false;

        if (characterId != Guid.Empty)
        {
            // Verify character exists and belongs to current user
            if (!await CharacterService.CharacterExistsAsync(characterId.Value, currentUserId))
            {
                characterName = "(Invalid Character)";
                AddMessage("Error: Character not found or access denied.", "text-danger");
                return;
            }

            var character = await CharacterService.GetCharacterByIdAsync(characterId.Value, currentUserId);
            if (character != null)
            {
                characterName = character.Name;
                
                // Ensure character has starting skills (for characters created before skill initialization was added)
                try
                {
                    await CharacterService.EnsureCharacterHasStartingSkillsAsync(characterId.Value, currentUserId);
                }
                catch (Exception ex)
                {
                    // Log the error but don't fail character loading
                    AddMessage($"Warning: There was an issue ensuring character skills are initialized: {ex.Message}", "text-warning");
                }
                
                // Load character vitals using actual character data
                var initialSnapshot = await CharacterService.GetCharacterHealthAsync(characterId.Value, currentUserId);
                if (initialSnapshot != null)
                {
                    ApplyHealthSnapshot(initialSnapshot);
                }
                
                // Load active effects (placeholder - implement in your character service)
                await LoadActiveEffects();
                
                // Get character's current room (or starting room if none set)
                currentRoomId = await CharacterService.GetCharacterCurrentRoomAsync(characterId.Value, currentUserId);
                _logger?.LogDebug("Play: CharacterService.GetCharacterCurrentRoomAsync returned {RoomId}", currentRoomId);

                if (currentRoomId.HasValue)
                {
                    currentRoom = await WorldService.GetRoomByIdAsync(currentRoomId.Value);
                    _logger?.LogDebug("Play: WorldService.GetRoomByIdAsync({RoomId}) returned {HasRoom}", currentRoomId, currentRoom != null);
                    if (currentRoom == null)
                    {
                        // Room doesn't exist, fall back to starting room
                        currentRoom = await WorldService.GetStartingRoomAsync();
                        _logger?.LogDebug("Play: WorldService.GetStartingRoomAsync returned {StartingRoomId} (fallback)", currentRoom?.Id);
                        currentRoomId = currentRoom?.Id;
                    }
                }
                else
                {
                    // No current room, use starting room
                    currentRoom = await WorldService.GetStartingRoomAsync();
                    _logger?.LogDebug("Play: WorldService.GetStartingRoomAsync returned {StartingRoomId} (no currentRoomId)", currentRoom?.Id);
                    currentRoomId = currentRoom?.Id;
                }

                if (currentRoom == null)
                {
                    AddMessage("Error: No starting room found! The world may not be properly configured.", "text-danger");
                    AddMessage("Please contact an administrator.", "text-warning");
                    return;
                }
                
                // At this point currentRoom/currentRoomId should be resolved. Render welcome + description and subscribe.
                if (currentRoom != null)
                {
                    AddMessage($"Welcome to {currentRoom.Zone.Name}!", "text-success");
                    AddMessage("Type 'look' to examine your surroundings.", "text-muted");

                    var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoom.Id);
                    AddMessage(roomDescription, "text-info");
                }
                else
                {
                    AddMessage("Welcome to Mordecai MUD!", "text-success");
                    AddMessage("Error: Unable to determine your location.", "text-danger");
                }
            }
            else
            {
                characterName = "(Invalid Character)";
                AddMessage("Error: Unable to load character data.", "text-danger");
                return;
            }
        }

        // Subscribe to messages for this character
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            MessageBroadcastService.MessageReceived += OnMessageReceived;
            await MessageBroadcastService.RegisterCharacterListenerAsync(
                characterId.Value,
                currentRoomId,
                currentRoom!.ZoneId,
                characterName,
                currentUserName,
                currentUserId);
            isSubscribed = true;
            _logger?.LogDebug("Play: Registered message listener for character {CharacterId} in room {RoomId}", characterId, currentRoomId);
        }

        _logger?.LogDebug("Play.OnInitializedAsync end - characterId={CharacterId} roomId={RoomId}", characterId, currentRoomId);

        // Announce player joining
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            var joinMessage = new PlayerJoined(characterId.Value, characterName, currentRoomId.Value);
            await MessagePublisher.PublishAsync(joinMessage);
        }

        if (characterId.HasValue)
        {
            StartHealthRefreshLoop();
        }

        StateHasChanged();
    }

    private void ApplyHealthSnapshot(CharacterHealthSnapshot snapshot)
    {
        currentFat = snapshot.CurrentFatigue;
        maxFat = snapshot.MaxFatigue;
        pendingFat = snapshot.PendingFatigueDamage;
        currentVit = snapshot.CurrentVitality;
        maxVit = snapshot.MaxVitality;
        pendingVit = snapshot.PendingVitalityDamage;
    }

    private static string FormatPendingChange(int pending)
    {
        if (pending == 0)
        {
            return "0";
        }

        var displayed = -pending;
        return $"{(displayed > 0 ? "+" : string.Empty)}{displayed}";
    }

    private async Task RefreshCharacterVitalsAsync()
    {
        if (!characterId.HasValue)
        {
            return;
        }

        try
        {
            var snapshot = await CharacterService.GetCharacterHealthAsync(characterId.Value, currentUserId);
            if (snapshot != null)
            {
                ApplyHealthSnapshot(snapshot);
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error refreshing vitals for character {CharacterId}", characterId);
        }
    }

    private async Task LoadActiveEffects()
    {
        // TODO: Implement actual active effects loading from your character service
        // This is placeholder data
        activeEffects = new List<ActiveEffect>();
        
        await Task.CompletedTask;
    }

    // We avoid OnAfterRenderAsync for room resolution; rely on data-binding and StateHasChanged in OnInitializedAsync.

    private void OnMessageReceived(Guid targetCharacterId, string message)
    {
        // Only handle messages for this character
        if (targetCharacterId == characterId)
        {
            InvokeAsync(() =>
            {
                AddMessage(message, "text-light");
                
                // Parse combat messages and add to combat log
                TryAddToCombatLog(message);
            });
        }
    }
    
    private void TryAddToCombatLog(string message)
    {
        // Check for combat-related CSS classes in the message
        var messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.Info;
        
        if (message.Contains("combat-start", StringComparison.OrdinalIgnoreCase))
        {
            messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.CombatStart;
            isInCombat = true;
        }
        else if (message.Contains("combat-end", StringComparison.OrdinalIgnoreCase))
        {
            messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.CombatEnd;
            // Keep log visible for a moment after combat ends
        }
        else if (message.Contains("combat-hit-dealt", StringComparison.OrdinalIgnoreCase))
        {
            messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.HitDealt;
        }
        else if (message.Contains("combat-hit-received", StringComparison.OrdinalIgnoreCase))
        {
            messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.HitReceived;
        }
        else if (message.Contains("combat-miss", StringComparison.OrdinalIgnoreCase))
        {
            messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.Miss;
        }
        else if (message.Contains("combat-flee", StringComparison.OrdinalIgnoreCase))
        {
            messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.Flee;
            isFleeing = message.Contains("flee", StringComparison.OrdinalIgnoreCase);
        }
        else if (message.Contains("combat-block", StringComparison.OrdinalIgnoreCase) || 
                 message.Contains("combat-parry", StringComparison.OrdinalIgnoreCase) ||
                 message.Contains("combat-dodge", StringComparison.OrdinalIgnoreCase))
        {
            // Blocks, parries, and dodges count as misses from the attacker's perspective
            messageType = Mordecai.Web.Components.CombatPanel.CombatMessageType.Miss;
        }
        else
        {
            // Not a combat message
            return;
        }
        
        // Extract plain text from HTML message for combat log
        var plainText = StripHtmlTags(message);
        
        combatLog.Add(new Mordecai.Web.Components.CombatPanel.CombatLogEntry
        {
            Timestamp = DateTime.Now,
            Message = plainText,
            MessageType = messageType
        });
        
        // Keep combat log at max size
        while (combatLog.Count > 20)
        {
            combatLog.RemoveAt(0);
        }
        
        StateHasChanged();
    }
    
    private static string StripHtmlTags(string html)
    {
        if (string.IsNullOrEmpty(html)) return html;
        
        // Simple HTML tag removal for display purposes
        var result = System.Text.RegularExpressions.Regex.Replace(html, "<[^>]*>", "");
        return System.Net.WebUtility.HtmlDecode(result).Trim();
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(50); // Small delay to ensure DOM is updated
        await JSRuntime.InvokeVoidAsync("scrollToBottom", gameOutputElement);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendCommand();
        }
        else if (e.Key == "ArrowUp")
        {
            NavigateHistory(-1);
        }
        else if (e.Key == "ArrowDown")
        {
            NavigateHistory(1);
        }
    }

    private void NavigateHistory(int direction)
    {
        if (commandHistory.Count == 0) return;

        historyIndex += direction;
        if (historyIndex < 0) historyIndex = 0;
        if (historyIndex >= commandHistory.Count) historyIndex = commandHistory.Count - 1;

        if (historyIndex >= 0 && historyIndex < commandHistory.Count)
        {
            currentCommand = commandHistory[historyIndex];
            StateHasChanged();
        }
    }

    private async Task SendCommand()
    {
        if (string.IsNullOrWhiteSpace(currentCommand) || isProcessing || !characterId.HasValue)
            return;

        isProcessing = true;
        var command = currentCommand.Trim();
        
        // Add to history
        if (!string.IsNullOrEmpty(command))
        {
            commandHistory.Add(command);
            if (commandHistory.Count > 50) // Limit history size
            {
                commandHistory.RemoveAt(0);
            }
            historyIndex = commandHistory.Count;
        }

        // Display the command
        AddMessage($"> {command}", "text-warning");

        // Process the command
        await ProcessGameCommand(command);
    await RefreshCharacterVitalsAsync();

        currentCommand = string.Empty;
        isProcessing = false;
        
    // Request focus restoration after processing
    StateHasChanged();
    }

    private void ExitGame()
    {
        // Announce player leaving if they're in the game
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            var disconnectMessage = new PlayerDisconnected(characterId.Value, characterName, currentRoomId.Value);
            _ = MessagePublisher.PublishAsync(disconnectMessage);
        }
        
        // Navigate back to character selection
        NavigationManager.NavigateTo("/characters");
    }

    private async Task ProcessGameCommand(string command)
    {
        if (!characterId.HasValue || !currentRoomId.HasValue || currentRoom == null) 
        {
            AddMessage("Error: Character or room data not properly loaded.", "text-danger");
            return;
        }

        // Simulate processing delay
        await Task.Delay(100);

        var cmd = command.ToLower().Trim();
        var partsList = command.Split(' ', StringSplitOptions.RemoveEmptyEntries).ToList();

        if (partsList.Count > 0 &&
            (string.Equals(partsList[0], "pickup", StringComparison.OrdinalIgnoreCase) ||
             string.Equals(partsList[0], "take", StringComparison.OrdinalIgnoreCase)))
        {
            partsList[0] = "get";
        }

        if (partsList.Count > 1 &&
            string.Equals(partsList[0], "pick", StringComparison.OrdinalIgnoreCase) &&
            string.Equals(partsList[1], "up", StringComparison.OrdinalIgnoreCase))
        {
            partsList.RemoveAt(1); // remove "up"
            partsList[0] = "get";
        }

        var parts = partsList.ToArray();
        var firstWord = parts.Length > 0 ? parts[0].ToLowerInvariant() : string.Empty;
        
        try
        {
            switch (firstWord)
            {
                case "look":
                case "l":
                case "examine":
                case "ex":
                    if (parts.Length > 1)
                    {
                        // Look at a specific direction
                        var direction = parts[1].ToLower();
                        await HandleLookDirectionCommand(direction);
                    }
                    else
                    {
                        // Look around the room
                        var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoom.Id);
                        AddMessage(roomDescription, "text-success");
                        await ShowRoomItemsAsync(currentRoom.Id);
                    }
                    break;

                case "search":
                    await HandleSearchCommand();
                    break;

                case "skills":
                    await HandleSkillsCommand();
                    break;

                case "drive":
                    await HandleDriveCommand();
                    break;

                case "inventory":
                case "inv":
                case "i":
                    await HandleInventoryCommand();
                    break;

                case "equipment":
                case "eq":
                    await HandleEquipmentCommand();
                    break;

                case "equip":
                case "wear":
                case "wield":
                    await HandleEquipCommand(parts);
                    break;

                case "unequip":
                case "remove":
                    await HandleUnequipCommand(parts);
                    break;

                case "drop":
                    await HandleDropCommand(parts);
                    break;

                case "get":
                    await HandleGetCommand(parts);
                    break;

                case "rezz":
                case "spawn-item":
                    await HandleSpawnItemCommand(parts);
                    break;

                case "spawn-npc":
                    await HandleSpawnNpcCommand(parts);
                    break;

                case "despawn":
                    await HandleDespawnCommand(parts);
                    break;

                case "list-npcs":
                    await HandleListNpcsCommand(parts);
                    break;

                case "list-items":
                    await HandleListItemsCommand(parts);
                    break;

                case "open":
                case "close":
                case "lock":
                case "unlock":
                case "break":
                case "force":
                    await HandleDoorCommand(firstWord, parts);
                    break;
                    
                case "help":
                    AddMessage("Available Commands:", "text-info");
                    AddMessage("look/l/examine/ex - Examine your surroundings");
                    AddMessage("look/l/examine/ex [direction] - Look in a specific direction (e.g., 'look north')");
                    AddMessage("search - Search for hidden things using your awareness skill (costs 1 FAT)");
                    AddMessage("skills - Display your character's skills and progress");
                    AddMessage("drive - Trade a portion of your vitality for fatigue recovery using the Drive skill");
                    AddMessage("inventory/inv/i - Show items you are carrying");
                    AddMessage("equipment/eq - Show what you have equipped");
                    AddMessage("equip/wear/wield [item] - Equip an item from your inventory");
                    AddMessage("unequip/remove [item] - Unequip an item");
                    AddMessage("drop [item] - Drop an item you are carrying into the room");
                    AddMessage("get [item] - Pick up an item from the ground");
                    if (isCurrentUserAdmin)
                    {
                        AddMessage("rezz [item template id or name] - Admin: manifest an item in your primary hand");
                    }
                    AddMessage("open/close [direction] - Open or close a door");
                    AddMessage("lock/unlock [direction] [device] - Lock or unlock a door with a device code");
                    AddMessage("break [direction] - Try to smash through a locked door");
                    AddMessage("say [message] - Speak to everyone in the room");
                    AddMessage("say [target] [message] - Speak to a specific character, NPC, or mob");
                    AddMessage("whisper [target] [message] - Whisper quietly to someone in the room");
                    AddMessage("tell [target] [message] - Speak privately to someone in the room");
                    AddMessage("yell|shout [message] - Raise your voice so nearby rooms hear you");
                    AddMessage("ooc [message] - Speak on the out-of-character channel");
                    AddMessage("emote [action] - Perform an emotive action");
                    AddMessage("who - See who else is online");
                    AddMessage("targets - List all possible targets in the room");
                    AddMessage("north/n, south/s, east/e, west/w - Move in those directions");
                    AddMessage("northeast/ne, northwest/nw, southeast/se, southwest/sw - Move diagonally");
                    AddMessage("up/u, down/d, in, out - Move vertically or through openings");
                    AddMessage("quit - Leave the game");
                    break;
                    
                case "who":
                    var activePlayers = MessageBroadcastService
                        .GetActiveCharacters()
                        .OrderBy(info => info.CharacterName, StringComparer.OrdinalIgnoreCase)
                        .ToList();

                    if (activePlayers.Count == 0)
                    {
                        AddMessage("No players are currently online.", "text-muted");
                        break;
                    }

                    AddMessage("Players currently online:", "text-info");

                    foreach (var player in activePlayers)
                    {
                        var isSelf = characterId.HasValue && player.CharacterId == characterId.Value;
                        var line = $"  {player.CharacterName}";

                        if (isSelf)
                        {
                            line += " (you)";
                        }

                        if (isCurrentUserAdmin && !string.IsNullOrWhiteSpace(player.UserDisplayName))
                        {
                            line += " - ";
                            line += player.UserDisplayName;
                        }

                        AddMessage(line);
                    }

                    var totalPlayers = activePlayers.Count;
                    AddMessage($"{totalPlayers} player{(totalPlayers == 1 ? string.Empty : "s")} total.");
                    break;
                    
                case "quit":
                    AddMessage("Thank you for playing Mordecai MUD!", "text-success");
                    AddMessage("Your progress has been saved.");
                    
                    // Announce player leaving
                    var disconnectMessage = new PlayerDisconnected(characterId.Value, characterName, currentRoomId.Value);
                    await MessagePublisher.PublishAsync(disconnectMessage);
                    break;
                    
                case "north": case "n":
                case "south": case "s":
                case "east": case "e":
                case "west": case "w":
                case "northeast": case "ne":
                case "northwest": case "nw":
                case "southeast": case "se":
                case "southwest": case "sw":
                case "up": case "u":
                case "down": case "d":
                case "in":
                case "out":
                    await HandleMovementCommand(cmd);
                    break;
                    
                case "targets":
                    var targets = await GameActionService.GetAvailableTargetsAsync(currentRoomId.Value, characterId);
                    if (targets.Any())
                    {
                        AddMessage("Available targets in this room:", "text-info");
                        foreach (var target in targets)
                        {
                            var typeDescription = target.Type switch
                            {
                                Mordecai.Messaging.Messages.TargetType.Character => "character",
                                Mordecai.Messaging.Messages.TargetType.Npc => "NPC",
                                Mordecai.Messaging.Messages.TargetType.Mob => "mob",
                                _ => "unknown"
                            };
                            var onlineStatus = target.IsOnline ? "" : " (offline)";
                            AddMessage($"  {target.Name} ({typeDescription}){onlineStatus}");
                        }
                    }
                    else
                    {
                        AddMessage("There are no other targets in this room.", "text-muted");
                    }
                    break;
                    
                default:
                    if (firstWord == "say")
                    {
                        await HandleSayCommand(parts);
                    }
                    else if (firstWord == "whisper")
                    {
                        await HandleWhisperCommand(parts);
                    }
                    else if (firstWord == "tell")
                    {
                        await HandleTellCommand(parts);
                    }
                    else if (firstWord == "yell" || firstWord == "shout")
                    {
                        await HandleYellCommand(parts);
                    }
                    else if (firstWord == "ooc" && parts.Length > 1)
                    {
                        await HandleOocCommand(parts);
                    }
                    else if (firstWord == "emote" && parts.Length > 1)
                    {
                        await HandleEmoteCommand(parts);
                    }
                    else
                    {
                        AddMessage($"Unknown command: '{command}'. Type 'help' for available commands.", "text-danger");
                    }
                    break;
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error processing command: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleDriveCommand()
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        try
        {
            var result = await CharacterService.TryPerformDriveConversionAsync(characterId.Value, currentUserId);

            if (!string.IsNullOrWhiteSpace(result.Feedback))
            {
                var feedbackClass = result.Success
                    ? "text-success"
                    : (!result.DiceRoll.HasValue && result.AbilityScore == 0 ? "text-danger" : "text-warning");
                AddMessage(result.Feedback, feedbackClass);
            }

            if (result.DiceRoll.HasValue && result.CheckTotal.HasValue)
            {
                AddMessage($"Drive check: AS {result.AbilityScore} {result.DiceRoll.Value:+0;-0;0} (4dF+) = {result.CheckTotal.Value} vs TV {result.TargetValue}.", "text-muted");
            }
            else if (result.AbilityScore > 0)
            {
                AddMessage($"Drive ability score {result.AbilityScore} vs TV {result.TargetValue}.", "text-muted");
            }

            if (result.Success)
            {
                AddMessage($"Pending health updated: +{result.VitalityDamageAmount} VIT damage, -{result.FatigueHealingAmount} FAT.", "text-info");
            }

            if (result.Snapshot != null)
            {
                ApplyHealthSnapshot(result.Snapshot);
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error performing Drive conversion: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleSpawnItemCommand(string[] parts)
    {
        if (!isCurrentUserAdmin)
        {
            AddMessage("Only administrators can use the spawn-item command.", "text-danger");
            return;
        }

        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (parts.Length < 2)
        {
            AddMessage("Usage: spawn-item [item template id or name]", "text-warning");
            AddMessage("Use 'list-items' to see available items.", "text-info");
            return;
        }

        try
        {
            var identifier = string.Join(" ", parts.Skip(1));
            ItemTemplate? template = null;

            if (int.TryParse(parts[1], out var templateId))
            {
                template = await ItemTemplateService.GetItemTemplateAsync(templateId);
            }

            if (template == null)
            {
                var templates = await ItemTemplateService.GetItemTemplatesAsync(includeInactive: true);
                template = templates
                    .FirstOrDefault(t => t.Name.Equals(identifier, StringComparison.OrdinalIgnoreCase));
            }

            if (template == null)
            {
                AddMessage($"No item template matches '{identifier}'.", "text-warning");
                AddMessage("Use 'list-items' to see available items.", "text-info");
                return;
            }

            var creationResult = await EquipmentService.CreateItemForCharacterAsync(characterId.Value, currentUserId, template.Id);
            var creationClass = creationResult.Success ? "text-success" : "text-warning";

            if (!creationResult.Success || creationResult.Item == null)
            {
                AddMessage(creationResult.Message, creationClass);
                return;
            }

            var equipResult = await EquipmentService.EquipAsync(characterId.Value, currentUserId, creationResult.Item.Id);

            if (equipResult.Success)
            {
                AddMessage($"[ADMIN] {template.Name} spawned and equipped to your primary hand.", "text-success");
            }
            else
            {
                AddMessage($"[ADMIN] {template.Name} spawned but could not be equipped: {equipResult.Message}", "text-warning");
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error using rezz: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleSpawnNpcCommand(string[] parts)
    {
        if (!isCurrentUserAdmin)
        {
            AddMessage("Only administrators can use the spawn-npc command.", "text-danger");
            return;
        }

        if (!currentRoomId.HasValue)
        {
            AddMessage("You must be in a room to spawn an NPC.", "text-danger");
            return;
        }

        if (parts.Length < 2)
        {
            AddMessage("Usage: spawn-npc [npc template id or name]", "text-warning");
            return;
        }

        try
        {
            var identifier = string.Join(" ", parts.Skip(1));
            NpcTemplate? template = null;

            if (int.TryParse(parts[1], out var templateId))
            {
                template = await DbContext.NpcTemplates.FindAsync(templateId);
            }

            if (template == null)
            {
                var templates = await DbContext.NpcTemplates.ToListAsync();
                template = templates
                    .FirstOrDefault(t => t.Name.Equals(identifier, StringComparison.OrdinalIgnoreCase));
            }

            if (template == null)
            {
                AddMessage($"No NPC template matches '{identifier}'.", "text-warning");
                AddMessage("Use 'list-npcs' to see available NPCs.", "text-info");
                return;
            }

            // Create a temporary spawner template and instance for this admin spawn
            var spawnerTemplate = new SpawnerTemplate
            {
                Name = $"[ADMIN] Temporary Spawner - {template.Name}",
                Description = "Created by admin spawn command",
                SpawnBehavior = SpawnBehavior.Fixed,
                SpawnIntervalMin = 0,
                SpawnIntervalMax = 0,
                MaxActiveCreatures = 1,
                RespawnOnDeath = false,
                CreatedBy = "admin-command",
                IsActive = true
            };

            DbContext.SpawnerTemplates.Add(spawnerTemplate);
            await DbContext.SaveChangesAsync();

            // Create the instance
            var spawnerInstance = new SpawnerInstance
            {
                SpawnerTemplateId = spawnerTemplate.Id,
                Type = SpawnerType.RoomBound,
                RoomId = currentRoomId.Value,
                IsEnabled = true,
                NextSpawnTime = DateTimeOffset.UtcNow
            };

            DbContext.SpawnerInstances.Add(spawnerInstance);
            await DbContext.SaveChangesAsync();

            // Add the NPC to the spawn table
            var spawnEntry = new SpawnerNpcEntry
            {
                SpawnerTemplateId = spawnerTemplate.Id,
                NpcTemplateId = template.Id,
                Weight = 100
            };

            DbContext.SpawnerNpcEntries.Add(spawnEntry);
            await DbContext.SaveChangesAsync();

            // Spawn the NPC immediately
            var npcId = await SpawnerService.TrySpawnNpcAsync(spawnerInstance.Id);

            if (npcId.HasValue)
            {
                AddMessage($"[ADMIN] {template.Name} spawned successfully.", "text-success");
                await RefreshCurrentRoomAsync();
            }
            else
            {
                AddMessage($"Failed to spawn {template.Name}.", "text-danger");
                // Clean up the temporary spawner
                DbContext.SpawnerInstances.Remove(spawnerInstance);
                DbContext.SpawnerTemplates.Remove(spawnerTemplate);
                await DbContext.SaveChangesAsync();
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error spawning NPC: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleDespawnCommand(string[] parts)
    {
        if (!isCurrentUserAdmin)
        {
            AddMessage("Only administrators can use the despawn command.", "text-danger");
            return;
        }

        if (!currentRoomId.HasValue)
        {
            AddMessage("You must be in a room to despawn an NPC.", "text-danger");
            return;
        }

        if (parts.Length < 2)
        {
            AddMessage("Usage: despawn [npc name or 'all']", "text-warning");
            return;
        }

        try
        {
            var identifier = string.Join(" ", parts.Skip(1));

            // Get all active spawns in current room
            var activeSpawns = await DbContext.ActiveSpawns
                .Include(a => a.NpcTemplate)
                .Include(a => a.SpawnerInstance)
                .Where(a => a.SpawnerInstance != null && a.SpawnerInstance.RoomId == currentRoomId.Value)
                .ToListAsync();

            if (!activeSpawns.Any())
            {
                AddMessage("There are no spawned NPCs in this room.", "text-warning");
                return;
            }

            if (identifier.Equals("all", StringComparison.OrdinalIgnoreCase))
            {
                var count = 0;
                foreach (var spawn in activeSpawns)
                {
                    await SpawnerService.DespawnNpcAsync(spawn.NpcId, DespawnReason.AdminCommand);
                    count++;
                }
                AddMessage($"[ADMIN] Despawned {count} NPC(s).", "text-success");
                await RefreshCurrentRoomAsync();
                return;
            }

            // Find specific NPC by name
            var matchingSpawn = activeSpawns
                .FirstOrDefault(a => a.NpcTemplate.Name.Equals(identifier, StringComparison.OrdinalIgnoreCase));

            if (matchingSpawn == null)
            {
                AddMessage($"No NPC named '{identifier}' found in this room.", "text-warning");
                AddMessage($"Available: {string.Join(", ", activeSpawns.Select(a => a.NpcTemplate.Name))}", "text-info");
                return;
            }

            await SpawnerService.DespawnNpcAsync(matchingSpawn.NpcId, DespawnReason.AdminCommand);
            AddMessage($"[ADMIN] {matchingSpawn.NpcTemplate.Name} despawned.", "text-success");
            await RefreshCurrentRoomAsync();
        }
        catch (Exception ex)
        {
            AddMessage($"Error despawning NPC: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleListNpcsCommand(string[] parts)
    {
        if (!isCurrentUserAdmin)
        {
            AddMessage("Only administrators can use the list-npcs command.", "text-danger");
            return;
        }

        try
        {
            var searchTerm = parts.Length > 1 ? string.Join(" ", parts.Skip(1)) : null;
            var templates = await DbContext.NpcTemplates.ToListAsync();

            if (!string.IsNullOrWhiteSpace(searchTerm))
            {
                templates = templates
                    .Where(t => t.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||
                               t.Description.Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
                    .ToList();
            }

            if (!templates.Any())
            {
                AddMessage("No NPC templates found.", "text-warning");
                return;
            }

            AddMessage("=== Available NPC Templates ===", "text-info");
            foreach (var template in templates.OrderBy(t => t.Id))
            {
                var level = template.Level > 0 ? $" (Level {template.Level})" : "";
                AddMessage($"  [{template.Id}] {template.Name}{level}", "text-muted");
                if (!string.IsNullOrWhiteSpace(template.ShortDescription))
                {
                    AddMessage($"      {template.ShortDescription}", "text-muted");
                }
            }
            AddMessage($"Total: {templates.Count} template(s)", "text-info");
            AddMessage("Use 'spawn-npc [id or name]' to spawn an NPC.", "text-info");
        }
        catch (Exception ex)
        {
            AddMessage($"Error listing NPCs: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleListItemsCommand(string[] parts)
    {
        if (!isCurrentUserAdmin)
        {
            AddMessage("Only administrators can use the list-items command.", "text-danger");
            return;
        }

        try
        {
            var searchTerm = parts.Length > 1 ? string.Join(" ", parts.Skip(1)) : null;
            var templates = await ItemTemplateService.GetItemTemplatesAsync(includeInactive: true);

            if (!string.IsNullOrWhiteSpace(searchTerm))
            {
                templates = templates
                    .Where(t => t.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase) ||
                               t.Description.Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
                    .ToList();
            }

            if (!templates.Any())
            {
                AddMessage("No item templates found.", "text-warning");
                return;
            }

            AddMessage("=== Available Item Templates ===", "text-info");
            foreach (var template in templates.OrderBy(t => t.Id))
            {
                var status = template.IsActive ? "" : " (Inactive)";
                var type = template.ItemType.ToString();
                AddMessage($"  [{template.Id}] {template.Name} ({type}){status}", "text-muted");
                if (!string.IsNullOrWhiteSpace(template.ShortDescription))
                {
                    AddMessage($"      {template.ShortDescription}", "text-muted");
                }
            }
            AddMessage($"Total: {templates.Count} template(s)", "text-info");
            AddMessage("Use 'spawn-item [id or name]' to spawn an item.", "text-info");
        }
        catch (Exception ex)
        {
            AddMessage($"Error listing items: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleDropCommand(string[] parts)
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (!currentRoomId.HasValue)
        {
            AddMessage("You have nowhere to drop that.", "text-danger");
            return;
        }

        if (parts.Length < 2)
        {
            AddMessage("Drop what? Usage: drop [item name]", "text-warning");
            return;
        }

        var itemName = string.Join(" ", parts.Skip(1));

        try
        {
            var items = await EquipmentService.GetInventoryItemsAsync(characterId.Value, currentUserId);
            Item? matchingItem;

            if (TryResolveSelection("drop", SelectionScope.Inventory, itemName, items, out var selectedItem, out var selectionError))
            {
                if (selectedItem == null)
                {
                    AddMessage(selectionError ?? "Unable to use that selection.", "text-warning");
                    return;
                }

                matchingItem = selectedItem;
            }
            else
            {
                var match = ResolveItemByName(items, itemName);

                switch (match.Status)
                {
                    case ItemMatchStatus.NotFound:
                        pendingSelection = null;
                        AddMessage($"You aren't holding anything matching '{itemName}'.", "text-warning");
                        return;
                    case ItemMatchStatus.Ambiguous:
                        PresentSelectionOptions("drop", SelectionScope.Inventory, match.Matches);
                        return;
                    case ItemMatchStatus.Success:
                        pendingSelection = null;
                        matchingItem = match.Item!;
                        break;
                    default:
                        AddMessage("Unable to determine which item to drop.", "text-warning");
                        return;
                }
            }

            var dropResult = await EquipmentService.DropItemAsync(characterId.Value, currentUserId, matchingItem.Id, currentRoomId.Value);
            var cssClass = dropResult.Success ? "text-success" : "text-warning";
            AddMessage(dropResult.Message, cssClass);

            if (dropResult.Success)
            {
                if (dropResult.Item != null && !IsCharacterHidden())
                {
                    await PublishItemDropMessageAsync(dropResult.Item);
                }

                await RefreshCurrentRoomAsync();
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error dropping item: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleGetCommand(string[] parts)
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (!currentRoomId.HasValue)
        {
            AddMessage("There's nothing here to take.", "text-danger");
            return;
        }

        if (parts.Length < 2)
        {
            AddMessage("Get what? Usage: get [item name]", "text-warning");
            return;
        }

        var itemName = string.Join(" ", parts.Skip(1));

        try
        {
            var items = await EquipmentService.GetRoomItemsAsync(currentRoomId.Value);
            Item? matchingItem;

            if (TryResolveSelection("get", SelectionScope.Room, itemName, items, out var selectedItem, out var selectionError))
            {
                if (selectedItem == null)
                {
                    AddMessage(selectionError ?? "Unable to use that selection.", "text-warning");
                    return;
                }

                matchingItem = selectedItem;
            }
            else
            {
                var match = ResolveItemByName(items, itemName);

                switch (match.Status)
                {
                    case ItemMatchStatus.NotFound:
                        pendingSelection = null;
                        AddMessage($"You don't see anything matching '{itemName}' here.", "text-warning");
                        return;
                    case ItemMatchStatus.Ambiguous:
                        PresentSelectionOptions("get", SelectionScope.Room, match.Matches);
                        return;
                    case ItemMatchStatus.Success:
                        pendingSelection = null;
                        matchingItem = match.Item!;
                        break;
                    default:
                        AddMessage("Unable to determine which item to pick up.", "text-warning");
                        return;
                }
            }

            var pickupResult = await EquipmentService.PickUpItemAsync(characterId.Value, currentUserId, matchingItem.Id, currentRoomId.Value);
            var cssClass = pickupResult.Success ? "text-success" : "text-warning";
            AddMessage(pickupResult.Message, cssClass);

            if (pickupResult.Success)
            {
                if (pickupResult.Item != null && !IsCharacterHidden())
                {
                    await PublishItemPickupMessageAsync(pickupResult.Item);
                }

                await RefreshCurrentRoomAsync();
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error picking up item: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleDoorCommand(string verb, string[] parts)
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (!currentRoomId.HasValue)
        {
            AddMessage("You are not currently in a room.", "text-danger");
            return;
        }

        var parsed = ParseDoorCommand(parts);
        if (!parsed.Success)
        {
            AddMessage(parsed.Error ?? "Specify a direction.", "text-warning");
            return;
        }

        DoorActionResult result;
        var direction = parsed.Direction!;

        try
        {
            result = verb switch
            {
                "open" => await DoorInteractionService.OpenAsync(characterId.Value, currentUserId, currentRoomId.Value, direction),
                "close" => await DoorInteractionService.CloseAsync(characterId.Value, currentUserId, currentRoomId.Value, direction),
                "lock" => await DoorInteractionService.LockWithDeviceAsync(characterId.Value, currentUserId, currentRoomId.Value, direction, parsed.DeviceCode ?? string.Empty),
                "unlock" => await DoorInteractionService.UnlockWithDeviceAsync(characterId.Value, currentUserId, currentRoomId.Value, direction, parsed.DeviceCode ?? string.Empty),
                "break" or "force" => await DoorInteractionService.AttemptBreakLockAsync(characterId.Value, currentUserId, currentRoomId.Value, direction),
                _ => DoorActionResult.Failure("That action is not supported.")
            };
        }
        catch (Exception ex)
        {
            AddMessage($"Error interacting with the door: {ex.Message}", "text-danger");
            return;
        }

        var cssClass = result.Success ? "text-success" : "text-warning";
        if (!string.IsNullOrWhiteSpace(result.Message))
        {
            AddMessage(result.Message, cssClass);
        }

        if (result.HasCheckDetails)
        {
            var roll = result.DiceRoll!.Value;
            var modifier = roll >= 0 ? $"+{roll}" : roll.ToString();
            AddMessage($"Physicality check: {result.AbilityScore} {modifier} = {result.Total} vs TV {result.TargetValue}.", result.Success ? "text-info" : "text-muted");
        }

        if (result.Success)
        {
            await RefreshCurrentRoomAsync();
        }
    }

    private static (bool Success, string? Direction, string? DeviceCode, string? Error) ParseDoorCommand(string[] parts)
    {
        if (parts.Length < 2)
        {
            return (false, null, null, "Specify a direction.");
        }

        var directionIndex = 1;
        if (parts[1].Equals("door", StringComparison.OrdinalIgnoreCase))
        {
            if (parts.Length < 3)
            {
                return (false, null, null, "Specify a direction.");
            }
            directionIndex = 2;
        }

        var direction = parts[directionIndex].ToLowerInvariant();
        string? deviceCode = null;

        if (parts.Length > directionIndex + 1)
        {
            deviceCode = string.Join(" ", parts.Skip(directionIndex + 1));
        }

        return (true, direction, deviceCode, null);
    }

    private async Task RefreshCurrentRoomAsync()
    {
        if (!currentRoomId.HasValue)
        {
            return;
        }

        currentRoom = await WorldService.GetRoomByIdAsync(currentRoomId.Value);
    }

    private async Task HandleSearchCommand()
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (!currentRoomId.HasValue)
        {
            AddMessage("You are not currently in a room to search.", "text-danger");
            return;
        }

        var activeCharacterId = characterId.Value;
        var currentRoomIdValue = currentRoomId.Value;

        try
        {
            var awarenessSkillId = await GetAwarenessSkillIdAsync();
            if (awarenessSkillId == null)
            {
                AddMessage("Your character doesn't seem to have developed awareness yet.", "text-warning");
                return;
            }

            var awarenessSkill = await SkillService.GetCharacterSkillAsync(activeCharacterId, awarenessSkillId.Value);

            if (awarenessSkill == null)
            {
                AddMessage("You don't seem to have developed your awareness skill yet.", "text-warning");
                return;
            }

            var character = await CharacterService.GetCharacterByIdAsync(activeCharacterId, currentUserId);
            if (character is null)
            {
                AddMessage("Unable to load your character data for this action.", "text-danger");
                return;
            }

            var fatigueResult = await CharacterService.TryConsumeFatigueAsync(activeCharacterId, currentUserId, 1, "You are too exhausted to search.");
            if (!fatigueResult.Success)
            {
                if (!string.IsNullOrWhiteSpace(fatigueResult.FailureReason))
                {
                    AddMessage(fatigueResult.FailureReason, "text-danger");
                }

                if (fatigueResult.Snapshot != null)
                {
                    ApplyHealthSnapshot(fatigueResult.Snapshot);
                }

                return;
            }

            if (fatigueResult.Snapshot != null)
            {
                ApplyHealthSnapshot(fatigueResult.Snapshot);
            }

            AddMessage("You carefully search the area for hidden things...", "text-info");

            using var diceService = new DiceService();
            var abilityScore = awarenessSkill.CalculateAbilityScore(character);
            var diceRoll = diceService.RollExploding4dF();
            var skillCheck = abilityScore + diceRoll;
            AddMessage($"Awareness check: {abilityScore} (AS) {diceRoll:+0;-0;0} (4dF+) = {skillCheck}", "text-muted");

            var searchOutcome = await PerformRoomSearch(skillCheck);

            var usageType = diceRoll >= 4
                ? Mordecai.Web.Data.SkillUsageType.CriticalSuccess
                : searchOutcome.FoundHiddenExit
                    ? Mordecai.Web.Data.SkillUsageType.ChallengingUse
                    : Mordecai.Web.Data.SkillUsageType.RoutineUse;
            var didAdvance = await SkillService.AddSkillUsageAsync(
                activeCharacterId,
                awarenessSkillId.Value,
                usageType,
                baseUsagePoints: 1,
                context: "Room Search",
                details: $"Skill check result: {skillCheck} (AS {abilityScore}, roll {diceRoll:+0;-0;0})"
            );

            if (searchOutcome.Discoveries.Any())
            {
                AddMessage("Your search reveals:", "text-success");
                foreach (var thing in searchOutcome.Discoveries)
                {
                    AddMessage($"  {thing}", "text-warning");
                }
            }
            else
            {
                AddMessage("You don't find anything hidden here.", "text-muted");
            }

            if (searchOutcome.HiddenExitsPresent && !searchOutcome.FoundHiddenExit)
            {
                AddMessage("Something about this place still feels concealed, but you can't pinpoint it yet.", "text-muted");
            }

            if (didAdvance)
            {
                var newSkill = await SkillService.GetCharacterSkillAsync(activeCharacterId, awarenessSkillId.Value);
                AddMessage($"Your awareness skill has improved to level {newSkill?.Level}!", "text-success");
            }

            var searchMessage = new EmoteMessage(activeCharacterId, characterName, currentRoomIdValue, "searches the area carefully");
            await MessagePublisher.PublishAsync(searchMessage);
        }
        catch (Exception ex)
        {
            AddMessage($"Error performing search: {ex.Message}", "text-danger");
        }
    }

    private const int DefaultHiddenExitTargetScore = 10;

    private sealed record RoomSearchResult(
        List<string> Discoveries,
        bool FoundHiddenExit,
        bool HiddenExitsPresent,
        int HighestTargetValue);

    private async Task<RoomSearchResult> PerformRoomSearch(int skillCheckResult)
    {
        var foundThings = new List<string>();

        var hiddenExits = await WorldService.GetHiddenExitsFromRoomAsync(currentRoomId!.Value);

        var hiddenExitsPresent = false;
        var foundHiddenExit = false;
        var highestTarget = 0;

        foreach (var exit in hiddenExits)
        {
            hiddenExitsPresent = true;

            var targetScore = exit.HiddenTargetScore > 0 ? exit.HiddenTargetScore : DefaultHiddenExitTargetScore;
            var skillRequirementPenalty = exit.SkillRequired.HasValue
                ? (int)Math.Ceiling(exit.SkillLevelRequired)
                : 0;
            var difficulty = targetScore + skillRequirementPenalty;
            highestTarget = Math.Max(highestTarget, difficulty);

            if (skillCheckResult >= difficulty)
            {
                foundHiddenExit = true;
                var description = exit.GetExitDescription() ?? $"a hidden passage {exit.Direction}";
                foundThings.Add($"A hidden exit {exit.Direction}: {description}");
            }
        }

        if (skillCheckResult >= 15)
        {
            foundThings.Add("subtle wear patterns on the floor suggesting hidden activity");
        }

        if (skillCheckResult >= 18)
        {
            foundThings.Add("faint scratch marks near what might be a concealed mechanism");
        }

        return new RoomSearchResult(foundThings, foundHiddenExit, hiddenExitsPresent, hiddenExitsPresent ? highestTarget : 0);
    }

    private async Task<int?> GetAwarenessSkillIdAsync()
    {
        try
        {
            // Look up the Awareness skill definition from the seeded data
            var skillCategories = await SkillService.GetSkillCategoriesAsync();
            var coreSkillsCategory = skillCategories.FirstOrDefault(c => c.Name == "Core Skills");
            if (coreSkillsCategory == null)
            {
                return null;
            }

            var awarenessSkill = coreSkillsCategory.Skills.FirstOrDefault(s => s.Name == "Awareness");
            return awarenessSkill?.Id;
        }
        catch (Exception ex)
        {
            AddMessage($"Error finding awareness skill: {ex.Message}", "text-danger");
            return null;
        }
    }

    private async Task HandleSkillsCommand()
    {
        try
        {
            AddMessage("=== Your Character Skills ===", "text-info");
            
            // Get all character skills organized by category
            var characterSkills = await SkillService.GetCharacterSkillsAsync(characterId!.Value);
            
            if (!characterSkills.Any())
            {
                AddMessage("You haven't developed any skills yet.", "text-warning");
                AddMessage("This shouldn't happen for properly initialized characters.", "text-muted");
                AddMessage("Try creating a new character or contact an administrator.", "text-muted");
                return;
            }

            // Group skills by category for organized display
            var skillsByCategory = characterSkills
                .GroupBy(cs => cs.SkillDefinition.Category.Name)
                .OrderBy(g => g.First().SkillDefinition.Category.DisplayOrder);

            foreach (var categoryGroup in skillsByCategory)
            {
                // Display category name
                AddMessage($"\n--- {categoryGroup.Key} ---", "text-warning");
                
                var skillsInCategory = categoryGroup
                    .OrderBy(cs => cs.SkillDefinition.DisplayOrder)
                    .ThenBy(cs => cs.SkillDefinition.Name);

                foreach (var characterSkill in skillsInCategory)
                {
                    var skill = characterSkill.SkillDefinition;
                    var currentLevel = characterSkill.Level;
                    var totalUsage = characterSkill.Experience;
                    var usageCount = characterSkill.UsageCount;
                    
                    // Calculate progress to next level (not the final level)
                    var usageForCurrentLevel = skill.CalculateTotalUsageForLevel(currentLevel);
                    var usageForNextLevel = skill.CalculateTotalUsageForLevel(currentLevel + 1);
                    var progressPoints = totalUsage - usageForCurrentLevel;
                    var requiredPointsForNextLevel = usageForNextLevel - usageForCurrentLevel;
                    var progressPercent = requiredPointsForNextLevel > 0 ? (progressPoints * 100.0m / requiredPointsForNextLevel) : 100.0m;
                    
                    // Create progress bar visualization
                    var progressBarLength = 20;
                    var filledBars = (int)(progressPercent / 100.0m * progressBarLength);
                    var progressBar = new string('?', filledBars) + new string('?', progressBarLength - filledBars);
                    
                    // Format the skill line
                    var skillLine = $"{skill.Name,-18} Level {currentLevel,2} [{progressBar}] {progressPercent:F1}%";
                    AddMessage($"  {skillLine}", "text-light");
                    
                    // Add usage information for detailed tracking - show progress to NEXT level, not final level
                    var usageInfo = $"    Usage: {progressPoints}/{requiredPointsForNextLevel} points ({usageCount} total uses)";
                    AddMessage(usageInfo, "text-muted");
                    
                    // Show last used information if available
                    if (characterSkill.LastUsedAt.HasValue)
                    {
                        var timeSinceLastUse = DateTimeOffset.UtcNow - characterSkill.LastUsedAt.Value;
                        var lastUsedText = timeSinceLastUse.TotalDays >= 1 
                            ? $"{timeSinceLastUse.Days} days ago"
                            : timeSinceLastUse.TotalHours >= 1 
                                ? $"{timeSinceLastUse.Hours} hours ago"
                                : "Recently";
                        AddMessage($"    Last used: {lastUsedText}", "text-muted");
                    }
                }
            }
            
            // Add summary statistics
            var totalSkills = characterSkills.Count;
            var averageLevel = characterSkills.Average(cs => cs.Level);
            var totalUsages = characterSkills.Sum(cs => cs.UsageCount);
            
            AddMessage($"\nSkill Summary:", "text-info");
            AddMessage($"  Total Skills: {totalSkills}", "text-light");
            AddMessage($"  Average Level: {averageLevel:F1}", "text-light");
            AddMessage($"  Total Skill Uses: {totalUsages:N0}", "text-light");
            
            // Show highest skill
            var highestSkill = characterSkills.OrderByDescending(cs => cs.Level).First();
            AddMessage($"  Highest Skill: {highestSkill.SkillDefinition.Name} (Level {highestSkill.Level})", "text-success");
            
            // Show available skill categories that the character doesn't have skills in yet
            var allCategories = await SkillService.GetSkillCategoriesAsync();
            var characterSkillCategoryNames = skillsByCategory.Select(g => g.Key).ToHashSet();
            var unusedCategories = allCategories
                .Where(c => !characterSkillCategoryNames.Contains(c.Name))
                .OrderBy(c => c.DisplayOrder)
                .ToList();
            
            if (unusedCategories.Any())
            {
                AddMessage($"\nSkill Categories Available for Learning:", "text-info");
                foreach (var category in unusedCategories)
                {
                    var skillCount = category.Skills.Count(s => s.IsActive && !s.IsStartingSkill);
                    if (skillCount > 0)
                    {
                        AddMessage($"  {category.Name}: {skillCount} skills available", "text-muted");
                    }
                }
                AddMessage("  (Skills in these categories can be learned through practice or training)", "text-muted");
            }
            
        }
        catch (Exception ex)
        {
            AddMessage($"Error displaying skills: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleMovementCommand(string direction)
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        // Normalize direction
        var normalizedDirection = direction switch
        {
            "n" => "north",
            "s" => "south", 
            "e" => "east",
            "w" => "west",
            "ne" => "northeast",
            "nw" => "northwest",
            "se" => "southeast",
            "sw" => "southwest",
            "u" => "up",
            "d" => "down",
            _ => direction
        };

        // Fetch exit details to evaluate traversal rules
        var exit = await WorldService.GetExitFromRoomAsync(currentRoomId!.Value, normalizedDirection);
        if (exit == null)
        {
            AddMessage("You cannot go that way.", "text-danger");
            return;
        }

        if (exit.IsDoorLocked)
        {
            var doorLabel = exit.GetDoorDisplayName();
            AddMessage($"The {doorLabel} to the {normalizedDirection} is locked.", "text-warning");
            return;
        }

        if (exit.IsDoorClosed)
        {
            var doorLabel = exit.GetDoorDisplayName();
            AddMessage($"The {doorLabel} to the {normalizedDirection} is closed.", "text-warning");
            return;
        }

        var destinationRoom = exit.ToRoom ?? await WorldService.GetRoomByExitAsync(currentRoomId.Value, normalizedDirection);
        if (destinationRoom == null)
        {
            AddMessage("That exit seems to lead nowhere.", "text-danger");
            return;
        }

        var fatigueResult = await CharacterService.TryConsumeFatigueAsync(characterId.Value, currentUserId, 1, "You are too exhausted to move.");
        if (!fatigueResult.Success)
        {
            if (!string.IsNullOrWhiteSpace(fatigueResult.FailureReason))
            {
                AddMessage(fatigueResult.FailureReason, "text-danger");
            }

            if (fatigueResult.Snapshot != null)
            {
                ApplyHealthSnapshot(fatigueResult.Snapshot);
            }

            return;
        }

        if (fatigueResult.Snapshot != null)
        {
            ApplyHealthSnapshot(fatigueResult.Snapshot);
        }

        // Announce leaving current room
        var leftMessage = new PlayerLeft(characterId!.Value, characterName, currentRoomId.Value, normalizedDirection);
        await MessagePublisher.PublishAsync(leftMessage);

        // Update current room
        var oldRoomId = currentRoomId.Value;
        var oldZoneId = currentRoom!.ZoneId;
        currentRoomId = destinationRoom.Id;
        currentRoom = destinationRoom;

        // Update character's room in the database (when CurrentRoomId field is added)
        await CharacterService.SetCharacterRoomAsync(characterId.Value, currentUserId, currentRoomId.Value);

        // Update message subscription
        MessageBroadcastService.UpdateCharacterRoom(characterId.Value, currentRoomId);
        if (oldZoneId != currentRoom.ZoneId)
        {
            MessageBroadcastService.UpdateCharacterZone(characterId.Value, currentRoom.ZoneId);
        }

        // Announce arriving in new room
        var movedMessage = new PlayerMoved(characterId.Value, characterName, oldRoomId, currentRoomId.Value, normalizedDirection);
        await MessagePublisher.PublishAsync(movedMessage);

        // Show movement and new room description
        AddMessage($"You go {normalizedDirection}.", "text-info");
        var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoomId.Value);
        AddMessage(roomDescription, "text-success");
    }

    private async Task HandleSayCommand(string[] parts)
    {
        string? targetName = null;
        string message;
        
        // Check if this might be a targeted say command
        if (parts.Length > 2)
        {
            // Try to parse as "say [target] [message]"
            var potentialTarget = parts[1];
            var remainingMessage = string.Join(" ", parts.Skip(2));
            
            // Check if the potential target exists
            var availableTargets = await GameActionService.GetAvailableTargetsAsync(currentRoomId!.Value, characterId);
            var foundTarget = availableTargets.FirstOrDefault(t => 
                t.Name.Equals(potentialTarget, StringComparison.OrdinalIgnoreCase) ||
                t.Name.ToLowerInvariant().StartsWith(potentialTarget.ToLowerInvariant()));
            
            if (foundTarget != null)
            {
                targetName = potentialTarget;
                message = remainingMessage;
            }
            else
            {
                // Not a valid target, treat as regular say with full message
                message = string.Join(" ", parts.Skip(1));
            }
        }
        else
        {
            // Regular say command
            message = string.Join(" ", parts.Skip(1));
        }

        if (!string.IsNullOrEmpty(message))
        {
            var result = await GameActionService.HandleChatMessageAsync(
                characterId!.Value, 
                characterName, 
                currentRoomId!.Value, 
                message, 
                ChatType.Say, 
                targetName);
            
            AddMessage(result, "text-success");
        }
        else
        {
            AddMessage("Say what?", "text-warning");
        }
    }

    private async Task HandleWhisperCommand(string[] parts)
    {
        if (parts.Length < 3)
        {
            AddMessage("Usage: whisper <target> <message>", "text-warning");
            return;
        }

        var targetName = parts[1];
        var message = string.Join(" ", parts.Skip(2));

        if (string.IsNullOrWhiteSpace(message))
        {
            AddMessage("Whisper what?", "text-warning");
            return;
        }

        var result = await GameActionService.HandleChatMessageAsync(
            characterId!.Value,
            characterName,
            currentRoomId!.Value,
            message,
            ChatType.Whisper,
            targetName);

        AddMessage(result, "text-success");
    }

    private async Task HandleTellCommand(string[] parts)
    {
        if (parts.Length < 3)
        {
            AddMessage("Usage: tell <target> <message>", "text-warning");
            return;
        }

        var targetName = parts[1];
        var message = string.Join(" ", parts.Skip(2));

        if (string.IsNullOrWhiteSpace(message))
        {
            AddMessage("Tell them what?", "text-warning");
            return;
        }

        var result = await GameActionService.HandleChatMessageAsync(
            characterId!.Value,
            characterName,
            currentRoomId!.Value,
            message,
            ChatType.Tell,
            targetName);

        AddMessage(result, "text-success");
    }

    private async Task HandleYellCommand(string[] parts)
    {
        var message = string.Join(" ", parts.Skip(1));

        if (string.IsNullOrWhiteSpace(message))
        {
            AddMessage("Yell what?", "text-warning");
            return;
        }

        var result = await GameActionService.HandleChatMessageAsync(
            characterId!.Value,
            characterName,
            currentRoomId!.Value,
            message,
            ChatType.Yell);

        AddMessage(result, "text-success");
    }

    private async Task HandleOocCommand(string[] parts)
    {
        var message = string.Join(" ", parts.Skip(1));
        if (!string.IsNullOrEmpty(message))
        {
            var globalChatMessage = new GlobalChatMessage(characterId!.Value, characterName, message, "ooc");
            await MessagePublisher.PublishAsync(globalChatMessage);
            
            AddMessage($"[OOC] You: {message}", "text-info");
        }
        else
        {
            AddMessage("Say what on OOC?", "text-warning");
        }
    }

    private async Task HandleEmoteCommand(string[] parts)
    {
        var emoteText = string.Join(" ", parts.Skip(1));
        if (!string.IsNullOrEmpty(emoteText))
        {
            var emoteMessage = new EmoteMessage(characterId!.Value, characterName, currentRoomId!.Value, emoteText);
            await MessagePublisher.PublishAsync(emoteMessage);
            
            AddMessage($"{characterName} {emoteText}.", "text-cyan");
        }
        else
        {
            AddMessage("Emote what?", "text-warning");
        }
    }

    private async Task HandleLookDirectionCommand(string direction)
    {
        // Normalize direction like movement commands
        var normalizedDirection = direction switch
        {
            "n" => "north",
            "s" => "south",
            "e" => "east",
            "w" => "west",
            "ne" => "northeast",
            "nw" => "northwest",
            "se" => "southeast",
            "sw" => "southwest",
            "u" => "up",
            "d" => "down",
            _ => direction
        };

        // Get the exit in that direction
        var exit = await WorldService.GetExitFromRoomAsync(currentRoomId!.Value, normalizedDirection);
        
        if (exit == null)
        {
            AddMessage($"You see nothing of interest to the {normalizedDirection}.", "text-muted");
            return;
        }

        if (exit.IsDoorClosed)
        {
            var doorLabel = exit.GetDoorDisplayName();
            AddMessage($"The {doorLabel} to the {normalizedDirection} is closed; you cannot see through it.", "text-warning");
            return;
        }

        // Build description for what they see in that direction
        var description = new List<string>();
        
        // Add exit description if available
        var exitDesc = exit.GetExitDescription(); // TODO: Pass isNight when time system is implemented
        if (!string.IsNullOrEmpty(exitDesc))
        {
            description.Add($"To the {normalizedDirection}, you see {exitDesc}.");
        }
        else
        {
            description.Add($"To the {normalizedDirection}, you can go to {exit.ToRoom.Name}.");
        }

        // Add destination room peek if not hidden
        if (!exit.IsHidden)
        {
            description.Add($"That direction leads to {exit.ToRoom.Name} in {exit.ToRoom.Zone.Name}.");
            
            // Add a brief peek at the destination room description (first sentence)
            var destinationDesc = exit.ToRoom.GetDescription(); // TODO: Pass isNight when time system is implemented
            var firstSentence = destinationDesc.Split('.', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
            if (!string.IsNullOrEmpty(firstSentence))
            {
                description.Add($"From here you can see: {firstSentence.Trim()}.");
            }
        }

        // Show any skill requirements
        if (exit.SkillRequired.HasValue && exit.SkillLevelRequired > 0)
        {
            description.Add($"This exit requires special skills to use (Skill Level {exit.SkillLevelRequired}).");
        }

        var finalDescription = string.Join(" ", description);
        AddMessage(finalDescription, "text-info");
    }

    private async Task HandleInventoryCommand()
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        try
        {
            // Get the character to access currency
            var character = await CharacterService.GetCharacterByIdAsync(characterId.Value, currentUserId);
            if (character == null)
            {
                AddMessage("Unable to load character data.", "text-danger");
                return;
            }

            // Display currency first
            AddMessage("Currency:", "text-info");
            var currencyDisplay = CurrencyService.FormatCoins(
                character.CopperCoins,
                character.SilverCoins,
                character.GoldCoins,
                character.PlatinumCoins);
            AddMessage($"  {currencyDisplay}", "text-warning");

            // Calculate coin weight
            var coinWeight = character.CoinWeight;
            if (coinWeight > 0)
            {
                AddMessage($"  (Coin weight: {coinWeight:F2} lbs)", "text-muted");
            }

            // Get items
            var items = await EquipmentService.GetInventoryItemsAsync(characterId.Value, currentUserId);
            
            if (items.Count == 0)
            {
                AddMessage("\nYour inventory is empty.", "text-muted");
                return;
            }

            AddMessage("\nInventory:", "text-info");
            foreach (var item in items)
            {
                var displayName = string.IsNullOrWhiteSpace(item.CustomName) 
                    ? item.ItemTemplate.Name 
                    : $"{item.CustomName} ({item.ItemTemplate.Name})";
                
                var equippedTag = item.IsEquipped ? " [EQUIPPED]" : "";
                var stackInfo = item.StackSize > 1 ? $" x{item.StackSize}" : "";
                
                var detail = FormatItemDetail(item);
                AddMessage($"  {displayName}{stackInfo}{equippedTag}{detail}");
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error retrieving inventory: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleEquipmentCommand()
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        try
        {
            var equippedItems = await EquipmentService.GetEquippedItemsAsync(characterId.Value, currentUserId);
            
            if (equippedItems.Count == 0)
            {
                AddMessage("You have nothing equipped.", "text-muted");
                return;
            }

            AddMessage("Currently Equipped:", "text-info");
            
            // Group by slot for organized display
            var itemsBySlot = equippedItems
                .GroupBy(i => i.EquippedSlot)
                .OrderBy(g => g.Key);

            foreach (var slotGroup in itemsBySlot)
            {
                var slotName = slotGroup.Key.HasValue ? slotGroup.Key.Value.ToString() : "Unknown";
                
                foreach (var item in slotGroup)
                {
                    var displayName = string.IsNullOrWhiteSpace(item.CustomName)
                        ? item.ItemTemplate.Name
                        : $"{item.CustomName} ({item.ItemTemplate.Name})";
                    
                    var detail = FormatItemDetail(item);
                    AddMessage($"  {slotName}: {displayName}{detail}");
                    
                    // Show bonuses if any
                    if (item.ItemTemplate.SkillBonuses?.Any() == true)
                    {
                        foreach (var bonus in item.ItemTemplate.SkillBonuses)
                        {
                            AddMessage($"    +{bonus.BonusValue} to {bonus.SkillDefinition.Name}", "text-success");
                        }
                    }
                    
                    if (item.ItemTemplate.AttributeModifiers?.Any() == true)
                    {
                        foreach (var modifier in item.ItemTemplate.AttributeModifiers)
                        {
                            AddMessage($"    {modifier.ModifierValue:+0;-0;0} to {modifier.AttributeName}", "text-success");
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error retrieving equipment: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleEquipCommand(string[] parts)
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (parts.Length < 2)
        {
            AddMessage("Equip what? Usage: equip [item name]", "text-warning");
            return;
        }

        var itemName = string.Join(" ", parts.Skip(1));

        try
        {
            // Find the item in the character's inventory by name
            var items = await EquipmentService.GetInventoryItemsAsync(characterId.Value, currentUserId);
            Item? matchingItem;

            if (TryResolveSelection("equip", SelectionScope.Inventory, itemName, items, out var selectedItem, out var selectionError))
            {
                if (selectedItem == null)
                {
                    AddMessage(selectionError ?? "Unable to use that selection.", "text-warning");
                    return;
                }

                matchingItem = selectedItem;
            }
            else
            {
                var match = ResolveItemByName(items, itemName);

                switch (match.Status)
                {
                    case ItemMatchStatus.NotFound:
                        pendingSelection = null;
                        AddMessage($"You don't have anything matching '{itemName}' in your inventory.", "text-warning");
                        return;
                    case ItemMatchStatus.Ambiguous:
                        PresentSelectionOptions("equip", SelectionScope.Inventory, match.Matches);
                        return;
                    case ItemMatchStatus.Success:
                        pendingSelection = null;
                        matchingItem = match.Item!;
                        break;
                    default:
                        AddMessage("Unable to determine which item to equip.", "text-warning");
                        return;
                }
            }

            var result = await EquipmentService.EquipAsync(characterId.Value, currentUserId, matchingItem.Id);
            
            if (result.Success)
            {
                AddMessage(result.Message, "text-success");
            }
            else
            {
                AddMessage(result.Message, "text-warning");
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error equipping item: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleUnequipCommand(string[] parts)
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (parts.Length < 2)
        {
            AddMessage("Unequip what? Usage: unequip [item name or slot]", "text-warning");
            return;
        }

        var targetName = string.Join(" ", parts.Skip(1));

        try
        {
            // Check if the target is a slot name
            if (Enum.TryParse<ArmorSlot>(targetName, true, out var slot) && slot != ArmorSlot.None)
            {
                var result = await EquipmentService.UnequipSlotAsync(characterId.Value, currentUserId, slot);
                
                if (result.Success)
                {
                    AddMessage(result.Message, "text-success");
                }
                else
                {
                    AddMessage(result.Message, "text-warning");
                }
                return;
            }

            // Otherwise, find the item by name or selection
            var equippedItems = await EquipmentService.GetEquippedItemsAsync(characterId.Value, currentUserId);
            Item? matchingItem;

            if (TryResolveSelection("unequip", SelectionScope.Equipped, targetName, equippedItems, out var selectedItem, out var selectionError))
            {
                if (selectedItem == null)
                {
                    AddMessage(selectionError ?? "Unable to use that selection.", "text-warning");
                    return;
                }

                matchingItem = selectedItem;
            }
            else
            {
                var match = ResolveItemByName(equippedItems, targetName);

                switch (match.Status)
                {
                    case ItemMatchStatus.NotFound:
                        pendingSelection = null;
                        AddMessage($"You don't have anything matching '{targetName}' equipped.", "text-warning");
                        return;
                    case ItemMatchStatus.Ambiguous:
                        PresentSelectionOptions("unequip", SelectionScope.Equipped, match.Matches);
                        return;
                    case ItemMatchStatus.Success:
                        pendingSelection = null;
                        matchingItem = match.Item!;
                        break;
                    default:
                        AddMessage("Unable to determine which item to unequip.", "text-warning");
                        return;
                }
            }

            var unequipResult = await EquipmentService.UnequipAsync(characterId.Value, currentUserId, matchingItem.Id);
            
            if (unequipResult.Success)
            {
                AddMessage(unequipResult.Message, "text-success");
            }
            else
            {
                AddMessage(unequipResult.Message, "text-warning");
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error unequipping item: {ex.Message}", "text-danger");
        }
    }

    private void AddMessage(string message, string cssClass = "")
    {
        var formattedMessage = !string.IsNullOrEmpty(cssClass) 
            ? $"<span class='{cssClass}'>{message}</span>" 
            : message;
        
        gameMessages.Add(formattedMessage);
        
        // Limit message history to prevent memory issues
        if (gameMessages.Count > 1000)
        {
            gameMessages.RemoveRange(0, 100);
        }
        
        // Scroll to bottom after adding message
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    private async Task ShowRoomItemsAsync(int roomId)
    {
        try
        {
            var items = await EquipmentService.GetRoomItemsAsync(roomId);

            if (items.Count == 0)
            {
                AddMessage("Nothing catches your eye on the ground.", "text-muted");
                return;
            }

            AddMessage("On the ground you see:", "text-info");

            foreach (var item in items)
            {
                var displayName = string.IsNullOrWhiteSpace(item.CustomName)
                    ? item.ItemTemplate.Name
                    : $"{item.CustomName} ({item.ItemTemplate.Name})";

                var stackInfo = item.StackSize > 1 ? $" x{item.StackSize}" : string.Empty;
                var detail = FormatItemDetail(item);
                AddMessage($"  {displayName}{stackInfo}{detail}");
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error listing room items: {ex.Message}", "text-danger");
        }
    }

    private bool IsCharacterHidden()
    {
        return activeEffects.Any(effect =>
            string.Equals(effect.EffectType, "Hidden", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(effect.EffectType, "Stealth", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(effect.Name, "Hidden", StringComparison.OrdinalIgnoreCase));
    }

    private enum ItemMatchStatus
    {
        NotFound,
        Ambiguous,
        Success
    }

    private sealed record ItemMatchResult(ItemMatchStatus Status, Item? Item, IReadOnlyList<string> Candidates, IReadOnlyList<Item> Matches);

    private enum SelectionScope
    {
        Inventory,
        Equipped,
        Room
    }

    private sealed record SelectionOption(Guid ItemId, string Label);

    private sealed record PendingItemSelection(string CommandKey, SelectionScope Scope, IReadOnlyList<SelectionOption> Options, DateTimeOffset CreatedAt);

    private ItemMatchResult ResolveItemByName(IEnumerable<Item> items, string searchTerm)
    {
        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            return new ItemMatchResult(ItemMatchStatus.NotFound, null, Array.Empty<string>(), Array.Empty<Item>());
        }

        var normalizedTerm = searchTerm.Trim();
        var lowerTerm = normalizedTerm.ToLowerInvariant();
        var matches = new List<(Item Item, int Weight)>();

        foreach (var item in items)
        {
            if (item.ItemTemplate == null)
            {
                continue;
            }

            var searchNames = GetItemSearchNames(item);

            if (searchNames.Any(name => string.Equals(name, normalizedTerm, StringComparison.OrdinalIgnoreCase)))
            {
                matches.Add((item, 0));
                continue;
            }

            var tokenSet = searchNames
                .SelectMany(ExtractSearchTokens)
                .ToHashSet(StringComparer.OrdinalIgnoreCase);

            if (tokenSet.Contains(lowerTerm))
            {
                matches.Add((item, 1));
                continue;
            }

            if (searchNames.Any(name => name.Contains(normalizedTerm, StringComparison.OrdinalIgnoreCase)))
            {
                matches.Add((item, 2));
            }
        }

        if (matches.Count == 0)
        {
            return new ItemMatchResult(ItemMatchStatus.NotFound, null, Array.Empty<string>(), Array.Empty<Item>());
        }

        var bestWeight = matches.Min(match => match.Weight);
        var bestMatches = matches
            .Where(match => match.Weight == bestWeight)
            .Select(match => match.Item)
            .Distinct()
            .ToList();

        if (bestMatches.Count == 1)
        {
            var item = bestMatches[0];
            return new ItemMatchResult(ItemMatchStatus.Success, item, new[] { GetItemLabel(item) }, bestMatches);
        }

        var candidateNames = bestMatches
            .Select(GetItemLabel)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToList();

        return new ItemMatchResult(ItemMatchStatus.Ambiguous, null, candidateNames, bestMatches);
    }

    private static IEnumerable<string> GetItemSearchNames(Item item)
    {
        var names = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        if (!string.IsNullOrWhiteSpace(item.CustomName))
        {
            names.Add(item.CustomName.Trim());
        }

        if (!string.IsNullOrWhiteSpace(item.ItemTemplate?.Name))
        {
            names.Add(item.ItemTemplate!.Name.Trim());
        }

        var label = GetItemLabel(item);
        if (!string.IsNullOrWhiteSpace(label))
        {
            names.Add(label.Trim());
        }

        return names;
    }

    private static IEnumerable<string> ExtractSearchTokens(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return Array.Empty<string>();
        }

    char[] separators = { ' ', '-', '_', '\'', '"', ',', '.', ';', ':', '(', ')', '[', ']', '{', '}', '/', '\\', '|' };
        return value
            .Split(separators, StringSplitOptions.RemoveEmptyEntries)
            .Select(token => token.ToLowerInvariant());
    }

    private static string GetItemLabel(Item item)
    {
        var templateName = item.ItemTemplate?.Name;
        var customName = item.CustomName;

        string label;

        if (!string.IsNullOrWhiteSpace(customName) && !string.IsNullOrWhiteSpace(templateName))
        {
            label = $"{customName} ({templateName})";
        }
        else if (!string.IsNullOrWhiteSpace(customName))
        {
            label = customName;
        }
        else if (!string.IsNullOrWhiteSpace(templateName))
        {
            label = templateName;
        }
        else
        {
            label = "item";
        }

        if (item.StackSize > 1)
        {
            label = $"{label} x{item.StackSize}";
        }

        return label;
    }

    private bool TryResolveSelection(string commandKey, SelectionScope scope, string searchTerm, IReadOnlyList<Item> items, out Item? selectedItem, out string? failureMessage)
    {
        selectedItem = null;
        failureMessage = null;

        if (!IsSelectionSpecifier(searchTerm, out var index))
        {
            return false;
        }

        if (pendingSelection is not { } selection ||
            !string.Equals(selection.CommandKey, commandKey, StringComparison.OrdinalIgnoreCase) ||
            selection.Scope != scope)
        {
            failureMessage = "No pending selection matches that number. Describe the item again to see options.";
            return true;
        }

        if (index < 1 || index > selection.Options.Count)
        {
            failureMessage = $"Select a number between 1 and {selection.Options.Count}.";
            return true;
        }

        var option = selection.Options[index - 1];
        var item = items.FirstOrDefault(i => i.Id == option.ItemId);

        if (item == null)
        {
            failureMessage = "That item is no longer available. Try again.";
            pendingSelection = null;
            return true;
        }

        selectedItem = item;
        pendingSelection = null;
        return true;
    }

    private static bool IsSelectionSpecifier(string value, out int index)
    {
        index = 0;

        if (string.IsNullOrWhiteSpace(value))
        {
            return false;
        }

        var trimmed = value.Trim();

        if (trimmed.StartsWith('#'))
        {
            trimmed = trimmed[1..];
        }

        return int.TryParse(trimmed, out index) && index > 0;
    }

    private void PresentSelectionOptions(string commandKey, SelectionScope scope, IReadOnlyList<Item> ambiguousItems)
    {
        var options = ambiguousItems
            .Select(item => new SelectionOption(item.Id, GetItemLabelWithContext(item, scope)))
            .ToList();

        if (options.Count == 0)
        {
            return;
        }

        pendingSelection = new PendingItemSelection(commandKey.ToLowerInvariant(), scope, options, DateTimeOffset.UtcNow);

        AddMessage("Multiple items match that description:", "text-warning");

        for (var i = 0; i < options.Count; i++)
        {
            AddMessage($"  {i + 1}. {options[i].Label}", "text-info");
        }

        AddMessage($"Type '{commandKey} 1' to choose the first item, '{commandKey} 2' for the second, and so on.", "text-muted");
    }

    private static string GetItemLabelWithContext(Item item, SelectionScope scope)
    {
        var label = GetItemLabel(item);

        return scope switch
        {
            SelectionScope.Inventory when item.IsEquipped && item.EquippedSlot.HasValue => $"{label} [equipped: {item.EquippedSlot.Value}]",
            SelectionScope.Inventory when item.IsEquipped => $"{label} [equipped]",
            SelectionScope.Inventory => $"{label} [inventory]",
            SelectionScope.Equipped when item.EquippedSlot.HasValue => $"{label} [slot: {item.EquippedSlot.Value}]",
            SelectionScope.Equipped => $"{label} [equipped]",
            SelectionScope.Room => $"{label} [ground]",
            _ => label
        };
    }

    private async Task PublishItemDropMessageAsync(Item item)
    {
        if (!characterId.HasValue || !currentRoomId.HasValue)
        {
            return;
        }

        var itemName = item.ItemTemplate?.Name ?? "item";
        var stackSize = Math.Max(1, item.StackSize);

        var message = new ItemDropped(
            characterId.Value,
            characterName,
            currentRoomId.Value,
            itemName,
            stackSize,
            item.CustomName);

        await MessagePublisher.PublishAsync(message);
    }

    private async Task PublishItemPickupMessageAsync(Item item)
    {
        if (!characterId.HasValue || !currentRoomId.HasValue)
        {
            return;
        }

        var itemName = item.ItemTemplate?.Name ?? "item";
        var stackSize = Math.Max(1, item.StackSize);

        var message = new ItemPickedUp(
            characterId.Value,
            characterName,
            currentRoomId.Value,
            itemName,
            stackSize,
            item.CustomName);

        await MessagePublisher.PublishAsync(message);
    }

    private static string FormatItemDetail(Item item)
    {
        var template = item.ItemTemplate;
        if (template == null)
        {
            return string.Empty;
        }

        var descriptors = new List<string>();

        if (template.ItemType == ItemType.Weapon && template.WeaponProperties is { } weapon)
        {
            descriptors.Add($"Weapon {weapon.DamageType} (CL {(int)weapon.DamageClass})");

            if (weapon.BaseSuccessValueModifier != 0)
            {
                descriptors.Add($"SV {FormatSignedValue(weapon.BaseSuccessValueModifier)}");
            }

            if (weapon.AttackValueModifier != 0)
            {
                descriptors.Add($"AV {FormatSignedValue(weapon.AttackValueModifier)}");
            }

            if (weapon.DodgeModifier != 0)
            {
                descriptors.Add($"DEX {FormatSignedValue(weapon.DodgeModifier)}");
            }

            if (weapon.Range != WeaponRange.Melee)
            {
                descriptors.Add($"Range {weapon.Range}");
            }

            if (weapon.CanKnockback)
            {
                descriptors.Add("Knockback");
            }

            if (weapon.IsTwoHanded)
            {
                descriptors.Add("Two-Handed");
            }

            if (weapon.RequiresAmmunition)
            {
                descriptors.Add("Ammo");
            }
        }
        else if (template.ItemType == ItemType.Armor && template.ArmorProperties is { } armor)
        {
            descriptors.Add($"Armor (CL {(int)armor.DamageClass})");

            var absorption = new List<string>();
            if (armor.BashingAbsorption != 0) absorption.Add($"B {armor.BashingAbsorption}");
            if (armor.CuttingAbsorption != 0) absorption.Add($"C {armor.CuttingAbsorption}");
            if (armor.PiercingAbsorption != 0) absorption.Add($"P {armor.PiercingAbsorption}");
            if (armor.ProjectileAbsorption != 0) absorption.Add($"Pr {armor.ProjectileAbsorption}");
            if (armor.EnergyAbsorption != 0) absorption.Add($"E {armor.EnergyAbsorption}");
            if (armor.HeatAbsorption != 0) absorption.Add($"H {armor.HeatAbsorption}");
            if (armor.ColdAbsorption != 0) absorption.Add($"Co {armor.ColdAbsorption}");
            if (armor.AcidAbsorption != 0) absorption.Add($"A {armor.AcidAbsorption}");
            if (absorption.Count > 0)
            {
                descriptors.Add(string.Join(", ", absorption));
            }

            if (armor.DodgeModifier != 0)
            {
                descriptors.Add($"DEX {FormatSignedValue(armor.DodgeModifier)}");
            }

            if (armor.StrengthModifier != 0)
            {
                descriptors.Add($"STR {FormatSignedValue(armor.StrengthModifier)}");
            }

            if (!string.IsNullOrWhiteSpace(armor.HitLocationCoverage))
            {
                descriptors.Add(armor.HitLocationCoverage!);
            }
        }

        return descriptors.Count == 0
            ? string.Empty
            : $" [{string.Join("; ", descriptors)}]";
    }

    private static string FormatSignedValue(int value) => value >= 0 ? $"+{value}" : value.ToString();

    public void Dispose()
    {
        if (isSubscribed && characterId.HasValue)
        {
            MessageBroadcastService.MessageReceived -= OnMessageReceived;
            _ = MessageBroadcastService.UnregisterCharacterListenerAsync(characterId.Value);
        }

        StopHealthRefreshLoop();
    }

    private void StartHealthRefreshLoop()
    {
        if (_healthRefreshTask != null)
        {
            return;
        }

        _healthRefreshCts = new CancellationTokenSource();
        var token = _healthRefreshCts.Token;

        _healthRefreshTask = Task.Run(async () =>
        {
            try
            {
                using var timer = new PeriodicTimer(HealthRefreshInterval);
                while (await timer.WaitForNextTickAsync(token))
                {
                    if (!characterId.HasValue)
                    {
                        continue;
                    }

                    try
                    {
                        var snapshot = await CharacterService.GetCharacterHealthAsync(characterId.Value, currentUserId);
                        if (snapshot != null)
                        {
                            await InvokeAsync(() =>
                            {
                                ApplyHealthSnapshot(snapshot);
                                StateHasChanged();
                            });
                        }
                        
                        // Refresh combat state
                        await RefreshCombatStateAsync();
                    }
                    catch (OperationCanceledException)
                    {
                        break;
                    }
                    catch (Exception ex)
                    {
                        await InvokeAsync(() => _logger?.LogError(ex, "Error refreshing character vitals in periodic loop"));
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // Expected during shutdown
            }
        }, token);
    }
    
    private async Task RefreshCombatStateAsync()
    {
        if (!characterId.HasValue) return;
        
        try
        {
            var combatState = await CombatService.GetCharacterCombatStateAsync(characterId.Value);
            
            await InvokeAsync(() =>
            {
                var wasInCombat = isInCombat;
                
                isInCombat = combatState.IsInCombat;
                combatSessionId = combatState.SessionId;
                isParryMode = combatState.IsParryMode;
                
                // If combat just ended, notify but keep the log visible briefly
                if (wasInCombat && !isInCombat)
                {
                    // Combat ended - log entry will be added by message handler
                }
                
                StateHasChanged();
            });
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Error refreshing combat state");
        }
    }

    private void StopHealthRefreshLoop()
    {
        try
        {
            _healthRefreshCts?.Cancel();
        }
        catch
        {
            // Ignored during disposal
        }
        finally
        {
            _healthRefreshCts?.Dispose();
            _healthRefreshCts = null;
            _healthRefreshTask = null;
        }
    }
}

<style>
    /* Override the normal layout structure for the play page */
    .play-page-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1000;
        background: #fff;
        display: flex;
        flex-direction: column;
    }
    
    .play-page-header {
        border-bottom: 1px solid #dee2e6;
        flex-shrink: 0;
        min-height: 50px;
    }
    
    .play-page-content {
        display: flex;
        flex: 1;
        min-height: 0;
    }
    
    .character-panel {
        width: 300px;
        border-right: 1px solid #dee2e6;
        max-height: 100%;
        overflow-y: auto;
        flex-shrink: 0;
    }
    
    .character-status {
        background: linear-gradient(135deg, #1a1a1a 0%, #2d3748 100%);
    }
    
    .character-header {
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.75rem;
    }
    
    .location-info {
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.75rem;
    }
    
    .vital-bar .progress {
        background-color: #2d3748;
        border: 1px solid #4a5568;
    }
    
    .effects-list {
        max-height: 200px;
        overflow-y: auto;
    }
    
    .effect-item {
        border-left: 3px solid #17a2b8;
    }
    
    .game-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
    }
    
    .game-container {
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        height: 100%;
        max-height: 100%;
    }
    
    .game-output-container {
        overflow: hidden;
        min-height: 0; /* Important for flex child to shrink */
    }
    
    .game-output {
        font-family: 'Courier New', monospace;
        line-height: 1.4;
        white-space: pre-wrap;
        word-wrap: break-word;
        scroll-behavior: smooth;
        height: 100% !important;
        max-height: 100%;
        overflow-y: auto !important;
        overflow-x: hidden;
    }
    
    .game-output::-webkit-scrollbar {
        width: 8px;
    }
    
    .game-output::-webkit-scrollbar-track {
        background: #2d3748;
    }
    
    .game-output::-webkit-scrollbar-thumb {
        background: #4a5568;
        border-radius: 4px;
    }
    
    .game-output::-webkit-scrollbar-thumb:hover {
        background: #718096;
    }
    
    .game-message {
        max-width: 100%;
        word-break: break-word;
    }

    .text-cyan {
        color: #17a2b8 !important;
    }
    
    .game-input {
        flex-shrink: 0; /* Prevent the input area from shrinking */
    }
    
    /* Mobile adjustments */
    media (max-width: 767.98px) {
        .character-panel {
            display: none !important;
        }
        
        .game-container {
            border-radius: 0;
            border: none;
            height: 100vh;
        }
        
        .game-output {
            font-size: 12px;
        }
        
        .play-page-header {
            font-size: 0.9rem;
        }
        
        .play-page-header h6 {
            font-size: 0.9rem;
        }
    }
    
    /* Responsive character panel toggle for smaller screens */
    media (max-width: 991.98px) {
        .character-panel {
            position: fixed;
            top: 50px; /* Account for header */
            left: -100%;
            width: 300px;
            height: calc(100vh - 50px);
            z-index: 1050;
            transition: left 0.3s ease;
            border-right: 1px solid #dee2e6;
            background-color: #1a1a1a;
        }
        
        .character-panel.show {
            left: 0;
        }
    }
</style>

<script>
    window.scrollToBottom = (element) => {
        if (element) {
            // Use requestAnimationFrame to ensure scrolling happens after DOM updates
            requestAnimationFrame(() => {
                element.scrollTop = element.scrollHeight;
            });
        }
    };
</script>