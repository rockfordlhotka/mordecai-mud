@page "/play/{characterId:guid}"
@page "/play"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using Mordecai.Web.Services
@using Mordecai.Messaging.Services
@using Mordecai.Messaging.Messages
@using Mordecai.Game.Entities
@using Mordecai.Web.Data
@attribute [Authorize]
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject CharacterMessageBroadcastService MessageBroadcastService
@inject IGameMessagePublisher MessagePublisher
@inject GameActionService GameActionService
@inject ICharacterService CharacterService
@inject IWorldService WorldService
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>Play Mordecai MUD</PageTitle>

<!-- Override the normal layout for the play page -->
<div class="play-page-container">
    <!-- Exit button and header -->
    <div class="play-page-header bg-dark text-white p-2 d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
            <button class="btn btn-outline-light btn-sm me-3" @onclick="ExitGame">
                <i class="oi oi-arrow-left me-1"></i>Exit Game
            </button>
            <h6 class="mb-0">Mordecai MUD - @characterName</h6>
        </div>
        <div class="small">
            @if (currentRoom != null)
            {
                <span>@currentRoom.Zone.Name - @currentRoom.Name</span>
            }
        </div>
    </div>
    
    <div class="play-page-content">
        <!-- Character Status Panel -->
        <div class="character-panel d-none d-md-block">
            <div class="character-status h-100 bg-dark text-white p-3">
                <div class="character-header mb-3">
                    <h5 class="text-success mb-1">@characterName</h5>
                    <small class="text-muted">@currentUserName</small>
                </div>
                
                <!-- Location Info -->
                @if (currentRoom != null)
                {
                    <div class="location-info mb-3">
                        <h6 class="text-info mb-1">Location</h6>
                        <div class="small">
                            <div>@currentRoom.Zone.Name</div>
                            <div>@currentRoom.Name</div>
                            <div class="text-muted">(@currentRoom.X, @currentRoom.Y, @currentRoom.Z)</div>
                        </div>
                    </div>
                }
                else if (currentRoomId.HasValue)
                {
                    <div class="location-info mb-3">
                        <h6 class="text-info mb-1">Location</h6>
                        <div class="small text-muted">Room ID: @currentRoomId</div>
                    </div>
                }

                <!-- Character Stats -->
                <div class="character-stats mb-3">
                    <h6 class="text-warning mb-2">Vitals</h6>
                    
                    <!-- FAT (Fatigue) -->
                    <div class="vital-bar mb-2">
                        <div class="d-flex justify-content-between small mb-1">
                            <span>FAT</span>
                            <span>@currentFat / @maxFat</span>
                        </div>
                        <div class="progress" style="height: 8px;">
                            <div class="progress-bar bg-warning" 
                                 style="width: @(maxFat > 0 ? (currentFat * 100.0 / maxFat) : 0)%"></div>
                        </div>
                        @if (pendingFat != currentFat)
                        {
                            <div class="small text-muted">Pending: @pendingFat</div>
                        }
                    </div>

                    <!-- VIT (Vitality/Health) -->
                    <div class="vital-bar mb-2">
                        <div class="d-flex justify-content-between small mb-1">
                            <span>VIT</span>
                            <span>@currentVit / @maxVit</span>
                        </div>
                        <div class="progress" style="height: 8px;">
                            <div class="progress-bar bg-danger" 
                                 style="width: @(maxVit > 0 ? (currentVit * 100.0 / maxVit) : 0)%"></div>
                        </div>
                        @if (pendingVit != currentVit)
                        {
                            <div class="small text-muted">Pending: @pendingVit</div>
                        }
                    </div>
                </div>

                <!-- Active Effects -->
                <div class="active-effects">
                    <h6 class="text-primary mb-2">Active Effects</h6>
                    <div class="effects-list">
                        @if (activeEffects.Any())
                        {
                            @foreach (var effect in activeEffects)
                            {
                                <div class="effect-item small mb-1 p-1 bg-secondary rounded">
                                    <div class="fw-bold">@effect.Name</div>
                                    @if (!string.IsNullOrEmpty(effect.Description))
                                    {
                                        <div class="text-muted">@effect.Description</div>
                                    }
                                    @if (effect.Duration.HasValue)
                                    {
                                        <div class="text-warning">@effect.Duration.Value.TotalSeconds.ToString("F0")s</div>
                                    }
                                </div>
                            }
                        }
                        else
                        {
                            <div class="small text-muted">No active effects</div>
                        }
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Game Area -->
        <div class="game-area">
            <div class="game-container h-100 d-flex flex-column">
                <!-- Mobile Header (visible on small screens) -->
                <div class="game-header bg-dark text-white p-2 d-md-none flex-shrink-0">
                    <h6 class="m-0">@characterName (@currentUserName)</h6>
                    @if (currentRoom != null)
                    {
                        <small class="text-muted">@currentRoom.Zone.Name - @currentRoom.Name</small>
                    }
                </div>
                
                <!-- Game Output Area -->
                <div class="game-output-container flex-grow-1 position-relative" style="min-height: 0;">
                    <div class="game-output h-100 p-3 bg-black text-light overflow-auto" 
                         style="font-family: 'Courier New', monospace; font-size: 14px;" 
                         @ref="gameOutputElement">
                        @if (gameMessages.Any())
                        {
                            @foreach (var message in gameMessages)
                            {
                                <div class="game-message mb-1">@((MarkupString)message)</div>
                            }
                        }
                        else
                        {
                            <div class="welcome-message">
                                <p class="text-success">Welcome to Mordecai MUD!</p>
                                <p>A skill-based, real-time text adventure where your actions shape your character.</p>
                                <p class="text-info">Getting Started:</p>
                                <ul>
                                    <li>Type <span class="text-warning">'look'</span> to examine your surroundings</li>
                                    <li>Type <span class="text-warning">'look [direction]'</span> to look in a specific direction (e.g., 'look north')</li>
                                    <li>Type <span class="text-warning">'help'</span> to see available commands</li>
                                    <li>Type <span class="text-warning">'who'</span> to see other players online</li>
                                    <li>Type <span class="text-warning">'say [message]'</span> to talk to others in the room</li>
                                </ul>
                                <p class="text-muted">Your character begins their journey here...</p>
                            </div>
                        }
                    </div>
                </div>
                
                <!-- Game Input Area -->
                <div class="game-input bg-secondary p-2 flex-shrink-0">
                    <div class="input-group">
                        <span class="input-group-text bg-dark text-light">&gt;</span>
                        <input @bind="currentCommand" @bind:event="oninput" @onkeydown="OnKeyDown" type="text" 
                               class="form-control bg-dark text-light border-secondary" 
                               placeholder="Enter command..." 
                               @ref="commandInput" />
                        <button class="btn btn-outline-light" @onclick="SendCommand" disabled="@isProcessing">
                            @if (isProcessing)
                            {
                                <span class="spinner-border spinner-border-sm me-1"></span>
                            }
                            Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] public Guid? characterId { get; set; }
    private string currentUserName = "Adventurer";
    private string characterName = "Unknown";
    private string currentUserId = string.Empty;
    private string currentCommand = string.Empty;
    private bool isProcessing = false;
    private ElementReference commandInput;
    private ElementReference gameOutputElement;
    private List<string> gameMessages = new();
    private List<string> commandHistory = new();
    private int historyIndex = -1;
    private int? currentRoomId = null;
    private Room? currentRoom = null;
    private bool isSubscribed = false;
    private bool shouldFocusInput = false;

    // Character vital stats - now loads from actual character data
    private int currentFat = 0;
    private int maxFat = 0;
    private int pendingFat = 0;
    private int currentVit = 0;
    private int maxVit = 0;
    private int pendingVit = 0;

    // Store the loaded character for health calculations
    private Character? loadedCharacter = null;

    // Active effects (placeholder - should come from your character service)
    private List<ActiveEffect> activeEffects = new();

    // Helper class for active effects
    private class ActiveEffect
    {
        public string Name { get; set; } = string.Empty;
        public string? Description { get; set; }
        public TimeSpan? Duration { get; set; }
        public string EffectType { get; set; } = string.Empty;
    }

    protected override async Task OnInitializedAsync()
    {
        // If no character ID provided, redirect to character selection
        if (characterId == null || characterId == Guid.Empty)
        {
            NavigationManager.NavigateTo("/characters");
            return;
        }

        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        currentUserName = user?.Identity?.Name ?? "Adventurer";
        currentUserId = user?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? string.Empty;

        if (characterId != Guid.Empty)
        {
            // Verify character exists and belongs to current user
            if (!await CharacterService.CharacterExistsAsync(characterId.Value, currentUserId))
            {
                characterName = "(Invalid Character)";
                AddMessage("Error: Character not found or access denied.", "text-danger");
                return;
            }

            var character = await CharacterService.GetCharacterByIdAsync(characterId.Value, currentUserId);
            if (character != null)
            {
                loadedCharacter = character;
                characterName = character.Name;
                
                // Load character vitals using actual character data
                await LoadCharacterVitals();
                
                // Load active effects (placeholder - implement in your character service)
                await LoadActiveEffects();
                
                // Get character's current room (or starting room if none set)
                currentRoomId = await CharacterService.GetCharacterCurrentRoomAsync(characterId.Value, currentUserId);
                
                if (currentRoomId.HasValue)
                {
                    currentRoom = await WorldService.GetRoomByIdAsync(currentRoomId.Value);
                    if (currentRoom == null)
                    {
                        // Room doesn't exist, fall back to starting room
                        currentRoom = await WorldService.GetStartingRoomAsync();
                        currentRoomId = currentRoom?.Id;
                    }
                }
                else
                {
                    // No current room, use starting room
                    currentRoom = await WorldService.GetStartingRoomAsync();
                    currentRoomId = currentRoom?.Id;
                }

                if (currentRoom == null)
                {
                    AddMessage("Error: No starting room found! The world may not be properly configured.", "text-danger");
                    AddMessage("Please contact an administrator.", "text-warning");
                    return;
                }
            }
            else
            {
                characterName = "(Invalid Character)";
                AddMessage("Error: Unable to load character data.", "text-danger");
                return;
            }
        }

        // Subscribe to messages for this character
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            MessageBroadcastService.MessageReceived += OnMessageReceived;
            await MessageBroadcastService.RegisterCharacterListenerAsync(characterId.Value, currentRoomId);
            isSubscribed = true;
        }
    }

    private async Task LoadCharacterVitals()
    {
        if (loadedCharacter == null)
        {
            // Fallback to safe defaults if character not loaded
            currentFat = maxFat = pendingFat = 15;
            currentVit = maxVit = pendingVit = 15;
            return;
        }

        // Calculate max health values from character's actual attributes
        // FAT = (Drive × 2) - 5
        maxFat = loadedCharacter.MaxFatigue;
        
        // VIT = (Physicality + Drive) - 5  
        maxVit = loadedCharacter.MaxVitality;

        // TODO: In the future, load current and pending values from the database
        // For now, assume character is at full health
        currentFat = maxFat;
        currentVit = maxVit;
        pendingFat = currentFat;
        pendingVit = currentVit;
        
        await Task.CompletedTask;
    }

    private async Task LoadActiveEffects()
    {
        // TODO: Implement actual active effects loading from your character service
        // This is placeholder data
        activeEffects = new List<ActiveEffect>();
        
        await Task.CompletedTask;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Focus the input on first render
            await commandInput.FocusAsync();

            if (currentRoom != null)
            {
                AddMessage($"Welcome to {currentRoom.Zone.Name}!", "text-success");
                AddMessage("Type 'look' to examine your surroundings.", "text-muted");
                
                // Show initial room description
                var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoom.Id);
                AddMessage(roomDescription, "text-info");
            }
            else
            {
                AddMessage("Welcome to Mordecai MUD!", "text-success");
                AddMessage("Error: Unable to determine your location.", "text-danger");
            }
            
            // Announce player joining
            if (characterId.HasValue && currentRoomId.HasValue)
            {
                var joinMessage = new PlayerJoined(characterId.Value, characterName, currentRoomId.Value);
                await MessagePublisher.PublishAsync(joinMessage);
            }
            
            StateHasChanged();
        }
        else if (shouldFocusInput)
        {
            // Only restore focus when explicitly requested (e.g., after sending command)
            await commandInput.FocusAsync();
            shouldFocusInput = false;
        }
    }

    private void OnMessageReceived(Guid targetCharacterId, string message)
    {
        // Only handle messages for this character
        if (targetCharacterId == characterId)
        {
            InvokeAsync(() =>
            {
                AddMessage(message, "text-light");
            });
        }
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(50); // Small delay to ensure DOM is updated
        await JSRuntime.InvokeVoidAsync("scrollToBottom", gameOutputElement);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendCommand();
        }
        else if (e.Key == "ArrowUp")
        {
            NavigateHistory(-1);
        }
        else if (e.Key == "ArrowDown")
        {
            NavigateHistory(1);
        }
    }

    private void NavigateHistory(int direction)
    {
        if (commandHistory.Count == 0) return;

        historyIndex += direction;
        if (historyIndex < 0) historyIndex = 0;
        if (historyIndex >= commandHistory.Count) historyIndex = commandHistory.Count - 1;

        if (historyIndex >= 0 && historyIndex < commandHistory.Count)
        {
            currentCommand = commandHistory[historyIndex];
            StateHasChanged();
        }
    }

    private async Task SendCommand()
    {
        if (string.IsNullOrWhiteSpace(currentCommand) || isProcessing || !characterId.HasValue)
            return;

        isProcessing = true;
        var command = currentCommand.Trim();
        
        // Add to history
        if (!string.IsNullOrEmpty(command))
        {
            commandHistory.Add(command);
            if (commandHistory.Count > 50) // Limit history size
            {
                commandHistory.RemoveAt(0);
            }
            historyIndex = commandHistory.Count;
        }

        // Display the command
        AddMessage($"> {command}", "text-warning");

        // Process the command
        await ProcessGameCommand(command);

        currentCommand = string.Empty;
        isProcessing = false;
        
        // Request focus restoration after processing
        shouldFocusInput = true;
        StateHasChanged();
    }

    private void ExitGame()
    {
        // Announce player leaving if they're in the game
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            var disconnectMessage = new PlayerDisconnected(characterId.Value, characterName, currentRoomId.Value);
            _ = MessagePublisher.PublishAsync(disconnectMessage);
        }
        
        // Navigate back to character selection
        NavigationManager.NavigateTo("/characters");
    }

    private async Task ProcessGameCommand(string command)
    {
        if (!characterId.HasValue || !currentRoomId.HasValue || currentRoom == null) 
        {
            AddMessage("Error: Character or room data not properly loaded.", "text-danger");
            return;
        }

        // Simulate processing delay
        await Task.Delay(100);

        var cmd = command.ToLower().Trim();
        var parts = command.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var firstWord = parts.Length > 0 ? parts[0].ToLower() : "";
        
        try
        {
            switch (firstWord)
            {
                case "look":
                case "l":
                case "examine":
                case "ex":
                    if (parts.Length > 1)
                    {
                        // Look at a specific direction
                        var direction = parts[1].ToLower();
                        await HandleLookDirectionCommand(direction);
                    }
                    else
                    {
                        // Look around the room
                        var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoom.Id);
                        AddMessage(roomDescription, "text-success");
                    }
                    break;
                    
                case "help":
                    AddMessage("Available Commands:", "text-info");
                    AddMessage("look/l/examine/ex - Examine your surroundings");
                    AddMessage("look/l/examine/ex [direction] - Look in a specific direction (e.g., 'look north')");
                    AddMessage("say [message] - Speak to everyone in the room");
                    AddMessage("say [target] [message] - Speak to a specific character, NPC, or mob");
                    AddMessage("ooc [message] - Speak on the out-of-character channel");
                    AddMessage("emote [action] - Perform an emotive action");
                    AddMessage("who - See who else is online");
                    AddMessage("targets - List all possible targets in the room");
                    AddMessage("north/n, south/s, east/e, west/w - Move in those directions");
                    AddMessage("northeast/ne, northwest/nw, southeast/se, southwest/sw - Move diagonally");
                    AddMessage("up/u, down/d, in, out - Move vertically or through openings");
                    AddMessage("quit - Leave the game");
                    break;
                    
                case "who":
                    AddMessage("Players currently online:", "text-info");
                    AddMessage($"  {currentUserName} (you)");
                    AddMessage("1 player total.");
                    break;
                    
                case "quit":
                    AddMessage("Thank you for playing Mordecai MUD!", "text-success");
                    AddMessage("Your progress has been saved.");
                    
                    // Announce player leaving
                    var disconnectMessage = new PlayerDisconnected(characterId.Value, characterName, currentRoomId.Value);
                    await MessagePublisher.PublishAsync(disconnectMessage);
                    break;
                    
                case "north": case "n":
                case "south": case "s":
                case "east": case "e":
                case "west": case "w":
                case "northeast": case "ne":
                case "northwest": case "nw":
                case "southeast": case "se":
                case "southwest": case "sw":
                case "up": case "u":
                case "down": case "d":
                case "in":
                case "out":
                    await HandleMovementCommand(cmd);
                    break;
                    
                case "targets":
                    var targets = await GameActionService.GetAvailableTargetsAsync(currentRoomId.Value, characterId);
                    if (targets.Any())
                    {
                        AddMessage("Available targets in this room:", "text-info");
                        foreach (var target in targets)
                        {
                            var typeDescription = target.Type switch
                            {
                                Mordecai.Messaging.Messages.TargetType.Character => "character",
                                Mordecai.Messaging.Messages.TargetType.Npc => "NPC",
                                Mordecai.Messaging.Messages.TargetType.Mob => "mob",
                                _ => "unknown"
                            };
                            var onlineStatus = target.IsOnline ? "" : " (offline)";
                            AddMessage($"  {target.Name} ({typeDescription}){onlineStatus}");
                        }
                    }
                    else
                    {
                        AddMessage("There are no other targets in this room.", "text-muted");
                    }
                    break;
                    
                default:
                    if (firstWord == "say" && parts.Length > 1)
                    {
                        await HandleSayCommand(parts);
                    }
                    else if (firstWord == "ooc" && parts.Length > 1)
                    {
                        await HandleOocCommand(parts);
                    }
                    else if (firstWord == "emote" && parts.Length > 1)
                    {
                        await HandleEmoteCommand(parts);
                    }
                    else
                    {
                        AddMessage($"Unknown command: '{command}'. Type 'help' for available commands.", "text-danger");
                    }
                    break;
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error processing command: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleMovementCommand(string direction)
    {
        // Normalize direction
        var normalizedDirection = direction switch
        {
            "n" => "north",
            "s" => "south", 
            "e" => "east",
            "w" => "west",
            "ne" => "northeast",
            "nw" => "northwest",
            "se" => "southeast",
            "sw" => "southwest",
            "u" => "up",
            "d" => "down",
            _ => direction
        };

        // Check if exit exists
        var canMove = await WorldService.CanMoveFromRoomAsync(currentRoomId!.Value, normalizedDirection);
        if (!canMove)
        {
            AddMessage("You cannot go that way.", "text-danger");
            return;
        }

        // Get destination room
        var destinationRoom = await WorldService.GetRoomByExitAsync(currentRoomId.Value, normalizedDirection);
        if (destinationRoom == null)
        {
            AddMessage("That exit seems to lead nowhere.", "text-danger");
            return;
        }

        // Announce leaving current room
        var leftMessage = new PlayerLeft(characterId!.Value, characterName, currentRoomId.Value, normalizedDirection);
        await MessagePublisher.PublishAsync(leftMessage);

        // Update current room
        var oldRoomId = currentRoomId.Value;
        currentRoomId = destinationRoom.Id;
        currentRoom = destinationRoom;

        // Update character's room in the database (when CurrentRoomId field is added)
        await CharacterService.SetCharacterRoomAsync(characterId.Value, currentUserId, currentRoomId.Value);

        // Update message subscription
        MessageBroadcastService.UpdateCharacterRoom(characterId.Value, currentRoomId);

        // Announce arriving in new room
        var movedMessage = new PlayerMoved(characterId.Value, characterName, oldRoomId, currentRoomId.Value, normalizedDirection);
        await MessagePublisher.PublishAsync(movedMessage);

        // Show movement and new room description
        AddMessage($"You go {normalizedDirection}.", "text-info");
        var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoomId.Value);
        AddMessage(roomDescription, "text-success");
    }

    private async Task HandleSayCommand(string[] parts)
    {
        string? targetName = null;
        string message;
        
        // Check if this might be a targeted say command
        if (parts.Length > 2)
        {
            // Try to parse as "say [target] [message]"
            var potentialTarget = parts[1];
            var remainingMessage = string.Join(" ", parts.Skip(2));
            
            // Check if the potential target exists
            var availableTargets = await GameActionService.GetAvailableTargetsAsync(currentRoomId!.Value, characterId);
            var foundTarget = availableTargets.FirstOrDefault(t => 
                t.Name.Equals(potentialTarget, StringComparison.OrdinalIgnoreCase) ||
                t.Name.ToLowerInvariant().StartsWith(potentialTarget.ToLowerInvariant()));
            
            if (foundTarget != null)
            {
                targetName = potentialTarget;
                message = remainingMessage;
            }
            else
            {
                // Not a valid target, treat as regular say with full message
                message = string.Join(" ", parts.Skip(1));
            }
        }
        else
        {
            // Regular say command
            message = string.Join(" ", parts.Skip(1));
        }

        if (!string.IsNullOrEmpty(message))
        {
            var result = await GameActionService.HandleChatMessageAsync(
                characterId!.Value, 
                characterName, 
                currentRoomId!.Value, 
                message, 
                ChatType.Say, 
                targetName);
            
            AddMessage(result, "text-success");
        }
        else
        {
            AddMessage("Say what?", "text-warning");
        }
    }

    private async Task HandleOocCommand(string[] parts)
    {
        var message = string.Join(" ", parts.Skip(1));
        if (!string.IsNullOrEmpty(message))
        {
            var globalChatMessage = new GlobalChatMessage(characterId!.Value, characterName, message, "ooc");
            await MessagePublisher.PublishAsync(globalChatMessage);
            
            AddMessage($"[OOC] You: {message}", "text-info");
        }
        else
        {
            AddMessage("Say what on OOC?", "text-warning");
        }
    }

    private async Task HandleEmoteCommand(string[] parts)
    {
        var emoteText = string.Join(" ", parts.Skip(1));
        if (!string.IsNullOrEmpty(emoteText))
        {
            var emoteMessage = new EmoteMessage(characterId!.Value, characterName, currentRoomId!.Value, emoteText);
            await MessagePublisher.PublishAsync(emoteMessage);
            
            AddMessage($"{characterName} {emoteText}.", "text-cyan");
        }
        else
        {
            AddMessage("Emote what?", "text-warning");
        }
    }

    private async Task HandleLookDirectionCommand(string direction)
    {
        // Normalize direction like movement commands
        var normalizedDirection = direction switch
        {
            "n" => "north",
            "s" => "south",
            "e" => "east",
            "w" => "west",
            "ne" => "northeast",
            "nw" => "northwest",
            "se" => "southeast",
            "sw" => "southwest",
            "u" => "up",
            "d" => "down",
            _ => direction
        };

        // Get the exit in that direction
        var exit = await WorldService.GetExitFromRoomAsync(currentRoomId!.Value, normalizedDirection);
        
        if (exit == null)
        {
            AddMessage($"You see nothing of interest to the {normalizedDirection}.", "text-muted");
            return;
        }

        // Build description for what they see in that direction
        var description = new List<string>();
        
        // Add exit description if available
        var exitDesc = exit.GetExitDescription(); // TODO: Pass isNight when time system is implemented
        if (!string.IsNullOrEmpty(exitDesc))
        {
            description.Add($"To the {normalizedDirection}, you see {exitDesc}.");
        }
        else
        {
            description.Add($"To the {normalizedDirection}, you can go to {exit.ToRoom.Name}.");
        }

        // Add destination room peek if not hidden
        if (!exit.IsHidden)
        {
            description.Add($"That direction leads to {exit.ToRoom.Name} in {exit.ToRoom.Zone.Name}.");
            
            // Add a brief peek at the destination room description (first sentence)
            var destinationDesc = exit.ToRoom.GetDescription(); // TODO: Pass isNight when time system is implemented
            var firstSentence = destinationDesc.Split('.', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
            if (!string.IsNullOrEmpty(firstSentence))
            {
                description.Add($"From here you can see: {firstSentence.Trim()}.");
            }
        }

        // Show any skill requirements
        if (exit.SkillRequired.HasValue && exit.SkillLevelRequired > 0)
        {
            description.Add($"This exit requires special skills to use (Skill Level {exit.SkillLevelRequired}).");
        }

        var finalDescription = string.Join(" ", description);
        AddMessage(finalDescription, "text-info");
    }

    private void AddMessage(string message, string cssClass = "")
    {
        var formattedMessage = !string.IsNullOrEmpty(cssClass) 
            ? $"<span class='{cssClass}'>{message}</span>" 
            : message;
        
        gameMessages.Add(formattedMessage);
        
        // Limit message history to prevent memory issues
        if (gameMessages.Count > 1000)
        {
            gameMessages.RemoveRange(0, 100);
        }
        
        // Scroll to bottom after adding message
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    public void Dispose()
    {
        if (isSubscribed && characterId.HasValue)
        {
            MessageBroadcastService.MessageReceived -= OnMessageReceived;
            _ = MessageBroadcastService.UnregisterCharacterListenerAsync(characterId.Value);
        }
    }
}

<style>
    /* Override the normal layout structure for the play page */
    .play-page-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1000;
        background: #fff;
        display: flex;
        flex-direction: column;
    }
    
    .play-page-header {
        border-bottom: 1px solid #dee2e6;
        flex-shrink: 0;
        min-height: 50px;
    }
    
    .play-page-content {
        display: flex;
        flex: 1;
        min-height: 0;
    }
    
    .character-panel {
        width: 300px;
        border-right: 1px solid #dee2e6;
        max-height: 100%;
        overflow-y: auto;
        flex-shrink: 0;
    }
    
    .character-status {
        background: linear-gradient(135deg, #1a1a1a 0%, #2d3748 100%);
    }
    
    .character-header {
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.75rem;
    }
    
    .location-info {
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.75rem;
    }
    
    .vital-bar .progress {
        background-color: #2d3748;
        border: 1px solid #4a5568;
    }
    
    .effects-list {
        max-height: 200px;
        overflow-y: auto;
    }
    
    .effect-item {
        border-left: 3px solid #17a2b8;
    }
    
    .game-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
    }
    
    .game-container {
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        height: 100%;
        max-height: 100%;
    }
    
    .game-output-container {
        overflow: hidden;
        min-height: 0; /* Important for flex child to shrink */
    }
    
    .game-output {
        font-family: 'Courier New', monospace;
        line-height: 1.4;
        white-space: pre-wrap;
        word-wrap: break-word;
        scroll-behavior: smooth;
        height: 100% !important;
        max-height: 100%;
        overflow-y: auto !important;
        overflow-x: hidden;
    }
    
    .game-output::-webkit-scrollbar {
        width: 8px;
    }
    
    .game-output::-webkit-scrollbar-track {
        background: #2d3748;
    }
    
    .game-output::-webkit-scrollbar-thumb {
        background: #4a5568;
        border-radius: 4px;
    }
    
    .game-output::-webkit-scrollbar-thumb:hover {
        background: #718096;
    }
    
    .game-message {
        max-width: 100%;
        word-break: break-word;
    }

    .text-cyan {
        color: #17a2b8 !important;
    }
    
    .game-input {
        flex-shrink: 0; /* Prevent the input area from shrinking */
    }
    
    /* Mobile adjustments */
    media (max-width: 767.98px) {
        .character-panel {
            display: none !important;
        }
        
        .game-container {
            border-radius: 0;
            border: none;
            height: 100vh;
        }
        
        .game-output {
            font-size: 12px;
        }
        
        .play-page-header {
            font-size: 0.9rem;
        }
        
        .play-page-header h6 {
            font-size: 0.9rem;
        }
    }
    
    /* Responsive character panel toggle for smaller screens */
    media (max-width: 991.98px) {
        .character-panel {
            position: fixed;
            top: 50px; /* Account for header */
            left: -100%;
            width: 300px;
            height: calc(100vh - 50px);
            z-index: 1050;
            transition: left 0.3s ease;
            border-right: 1px solid #dee2e6;
            background-color: #1a1a1a;
        }
        
        .character-panel.show {
            left: 0;
        }
    }
</style>

<script>
    window.scrollToBottom = (element) => {
        if (element) {
            // Use requestAnimationFrame to ensure scrolling happens after DOM updates
            requestAnimationFrame(() => {
                element.scrollTop = element.scrollHeight;
            });
        }
    };
</script>