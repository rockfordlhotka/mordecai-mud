@page "/play/{characterId:guid}"
@page "/play"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using Mordecai.Web.Services
@using Mordecai.Messaging.Services
@using Mordecai.Messaging.Messages
@using Mordecai.Game.Entities
@using Mordecai.Web.Data
@using System.Threading
@using System.Linq
@attribute [Authorize]
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject CharacterMessageBroadcastService MessageBroadcastService
@inject IGameMessagePublisher MessagePublisher
@inject GameActionService GameActionService
@inject ICharacterService CharacterService
@inject IWorldService WorldService
@inject SkillService SkillService
@inject IJSRuntime JSRuntime
@inject ILoggerFactory LoggerFactory
@implements IDisposable

<PageTitle>Play Mordecai MUD</PageTitle>

<!-- Override the normal layout for the play page -->
<div class="play-page-container">
    <!-- Exit button and header -->
    <div class="play-page-header bg-dark text-white p-2 d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
            <button class="btn btn-outline-light btn-sm me-3" @onclick="ExitGame">
                <i class="oi oi-arrow-left me-1"></i>Exit Game
            </button>
            <h6 class="mb-0">Mordecai MUD - @characterName</h6>
        </div>
        <div class="small">
            @if (currentRoom != null)
            {
                <span>@currentRoom.Zone.Name - @currentRoom.Name</span>
            }
        </div>
    </div>
    
    <div class="play-page-content">
        <!-- Character Status Panel -->
        <div class="character-panel d-none d-md-block">
            <div class="character-status h-100 bg-dark text-white p-3">
                <div class="character-header mb-3">
                    <h5 class="text-success mb-1">@characterName</h5>
                    <small class="text-muted">@currentUserName</small>
                </div>
                
                <!-- Location Info -->
                @if (currentRoom != null)
                {
                    <div class="location-info mb-3">
                        <h6 class="text-info mb-1">Location</h6>
                        <div class="small">
                            <div>@currentRoom.Zone.Name</div>
                            <div>@currentRoom.Name</div>
                            <div class="text-muted">(@currentRoom.X, @currentRoom.Y, @currentRoom.Z)</div>
                        </div>
                    </div>
                }
                else if (currentRoomId.HasValue)
                {
                    <div class="location-info mb-3">
                        <h6 class="text-info mb-1">Location</h6>
                        <div class="small text-muted">Room ID: @currentRoomId</div>
                    </div>
                }

                <!-- Character Stats -->
                <div class="character-stats mb-3">
                    <h6 class="text-warning mb-2">Vitals</h6>
                    
                    <!-- FAT (Fatigue) -->
                    <div class="vital-bar mb-2">
                        <div class="d-flex justify-content-between small mb-1">
                            <span>FAT</span>
                            <span>@currentFat / @maxFat</span>
                        </div>
                        <div class="progress" style="height: 8px;">
                            <div class="progress-bar bg-warning" 
                                 style="width: @(maxFat > 0 ? (currentFat * 100.0 / maxFat) : 0)%"></div>
                        </div>
                        @if (pendingFat != 0)
                        {
                            <div class="small text-muted">Pending: @FormatPendingChange(pendingFat)</div>
                        }
                    </div>

                    <!-- VIT (Vitality/Health) -->
                    <div class="vital-bar mb-2">
                        <div class="d-flex justify-content-between small mb-1">
                            <span>VIT</span>
                            <span>@currentVit / @maxVit</span>
                        </div>
                        <div class="progress" style="height: 8px;">
                            <div class="progress-bar bg-danger" 
                                 style="width: @(maxVit > 0 ? (currentVit * 100.0 / maxVit) : 0)%"></div>
                        </div>
                        @if (pendingVit != 0)
                        {
                            <div class="small text-muted">Pending: @FormatPendingChange(pendingVit)</div>
                        }
                    </div>
                </div>

                <!-- Active Effects -->
                <div class="active-effects">
                    <h6 class="text-primary mb-2">Active Effects</h6>
                    <div class="effects-list">
                        @if (activeEffects.Any())
                        {
                            @foreach (var effect in activeEffects)
                            {
                                <div class="effect-item small mb-1 p-1 bg-secondary rounded">
                                    <div class="fw-bold">@effect.Name</div>
                                    @if (!string.IsNullOrEmpty(effect.Description))
                                    {
                                        <div class="text-muted">@effect.Description</div>
                                    }
                                    @if (effect.Duration.HasValue)
                                    {
                                        <div class="text-warning">@effect.Duration.Value.TotalSeconds.ToString("F0")s</div>
                                    }
                                </div>
                            }
                        }
                        else
                        {
                            <div class="small text-muted">No active effects</div>
                        }
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Game Area -->
        <div class="game-area">
            <div class="game-container h-100 d-flex flex-column">
                <!-- Mobile Header (visible on small screens) -->
                <div class="game-header bg-dark text-white p-2 d-md-none flex-shrink-0">
                    <h6 class="m-0">@characterName (@currentUserName)</h6>
                    @if (currentRoom != null)
                    {
                        <small class="text-muted">@currentRoom.Zone.Name - @currentRoom.Name</small>
                    }
                </div>
                
                <!-- Game Output Area -->
                <div class="game-output-container flex-grow-1 position-relative" style="min-height: 0;">
                    <div class="game-output h-100 p-3 bg-black text-light overflow-auto" 
                         style="font-family: 'Courier New', monospace; font-size: 14px;" 
                         @ref="gameOutputElement">
                        @if (gameMessages.Any())
                        {
                            @foreach (var message in gameMessages)
                            {
                                <div class="game-message mb-1">@((MarkupString)message)</div>
                            }
                        }
                        else
                        {
                            <div class="welcome-message">
                                <p class="text-success">Welcome to Mordecai MUD!</p>
                                <p>A skill-based, real-time text adventure where your actions shape your character.</p>
                                <p class="text-info">Getting Started:</p>
                                <ul>
                                    <li>Type <span class="text-warning">'look'</span> to examine your surroundings</li>
                                    <li>Type <span class="text-warning">'look [direction]'</span> to look in a specific direction (e.g., 'look north')</li>
                                    <li>Type <span class="text-warning">'search'</span> to search for hidden things using your awareness</li>
                                    <li>Type <span class="text-warning">'skills'</span> to view your character's skills and progress</li>
                                    <li>Type <span class="text-warning">'help'</span> to see available commands</li>
                                    <li>Type <span class="text-warning">'who'</span> to see other players online</li>
                                    <li>Type <span class="text-warning">'say [message]'</span> to talk to others in the room</li>
                                </ul>
                                <p class="text-muted">Your character begins their journey here...</p>
                            </div>
                        }
                    </div>
                </div>
                
                <!-- Game Input Area -->
                <div class="game-input bg-secondary p-2 flex-shrink-0">
                    <div class="input-group">
                        <span class="input-group-text bg-dark text-light">&gt;</span>
                        <input @bind="currentCommand" @bind:event="oninput" @onkeydown="OnKeyDown" type="text" 
                               class="form-control bg-dark text-light border-secondary" 
                               placeholder="Enter command..." 
                               @ref="commandInput" />
                        <button class="btn btn-outline-light" @onclick="SendCommand" disabled="@isProcessing">
                            @if (isProcessing)
                            {
                                <span class="spinner-border spinner-border-sm me-1"></span>
                            }
                            Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] public Guid? characterId { get; set; }
    private string currentUserName = "Adventurer";
    private string characterName = "Unknown";
    private string currentUserId = string.Empty;
    private bool isCurrentUserAdmin = false;
    private string currentCommand = string.Empty;
    private bool isProcessing = false;
    private ElementReference commandInput;
    private ElementReference gameOutputElement;
    private List<string> gameMessages = new();
    private List<string> commandHistory = new();
    private int historyIndex = -1;
    private int? currentRoomId = null;
    private Room? currentRoom = null;
    private bool isSubscribed = false;
    private Task? _healthRefreshTask;
    private CancellationTokenSource? _healthRefreshCts;
    private static readonly TimeSpan HealthRefreshInterval = TimeSpan.FromSeconds(3);

    // Character vital stats - now loads from actual character data
    private int currentFat = 0;
    private int maxFat = 0;
    private int pendingFat = 0;
    private int currentVit = 0;
    private int maxVit = 0;
    private int pendingVit = 0;

    // Active effects (placeholder - should come from your character service)
    private List<ActiveEffect> activeEffects = new();

    // Helper class for active effects
    private class ActiveEffect
    {
        public string Name { get; set; } = string.Empty;
        public string? Description { get; set; }
        public TimeSpan? Duration { get; set; }
        public string EffectType { get; set; } = string.Empty;
    }

    private ILogger? _logger;

    protected override async Task OnInitializedAsync()
    {
        _logger ??= LoggerFactory?.CreateLogger("Play.razor");
        _logger?.LogDebug("Play.OnInitializedAsync start - characterId={CharacterId}", characterId);
        // If no character ID provided, redirect to character selection
        if (characterId == null || characterId == Guid.Empty)
        {
            NavigationManager.NavigateTo("/characters");
            return;
        }

        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        currentUserName = user?.Identity?.Name ?? "Adventurer";
        currentUserId = user?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value ?? string.Empty;
    isCurrentUserAdmin = user?.IsInRole("Admin") ?? false;

        if (characterId != Guid.Empty)
        {
            // Verify character exists and belongs to current user
            if (!await CharacterService.CharacterExistsAsync(characterId.Value, currentUserId))
            {
                characterName = "(Invalid Character)";
                AddMessage("Error: Character not found or access denied.", "text-danger");
                return;
            }

            var character = await CharacterService.GetCharacterByIdAsync(characterId.Value, currentUserId);
            if (character != null)
            {
                characterName = character.Name;
                
                // Ensure character has starting skills (for characters created before skill initialization was added)
                try
                {
                    await CharacterService.EnsureCharacterHasStartingSkillsAsync(characterId.Value, currentUserId);
                }
                catch (Exception ex)
                {
                    // Log the error but don't fail character loading
                    AddMessage($"Warning: There was an issue ensuring character skills are initialized: {ex.Message}", "text-warning");
                }
                
                // Load character vitals using actual character data
                var initialSnapshot = await CharacterService.GetCharacterHealthAsync(characterId.Value, currentUserId);
                if (initialSnapshot != null)
                {
                    ApplyHealthSnapshot(initialSnapshot);
                }
                
                // Load active effects (placeholder - implement in your character service)
                await LoadActiveEffects();
                
                // Get character's current room (or starting room if none set)
                currentRoomId = await CharacterService.GetCharacterCurrentRoomAsync(characterId.Value, currentUserId);
                _logger?.LogDebug("Play: CharacterService.GetCharacterCurrentRoomAsync returned {RoomId}", currentRoomId);

                if (currentRoomId.HasValue)
                {
                    currentRoom = await WorldService.GetRoomByIdAsync(currentRoomId.Value);
                    _logger?.LogDebug("Play: WorldService.GetRoomByIdAsync({RoomId}) returned {HasRoom}", currentRoomId, currentRoom != null);
                    if (currentRoom == null)
                    {
                        // Room doesn't exist, fall back to starting room
                        currentRoom = await WorldService.GetStartingRoomAsync();
                        _logger?.LogDebug("Play: WorldService.GetStartingRoomAsync returned {StartingRoomId} (fallback)", currentRoom?.Id);
                        currentRoomId = currentRoom?.Id;
                    }
                }
                else
                {
                    // No current room, use starting room
                    currentRoom = await WorldService.GetStartingRoomAsync();
                    _logger?.LogDebug("Play: WorldService.GetStartingRoomAsync returned {StartingRoomId} (no currentRoomId)", currentRoom?.Id);
                    currentRoomId = currentRoom?.Id;
                }

                if (currentRoom == null)
                {
                    AddMessage("Error: No starting room found! The world may not be properly configured.", "text-danger");
                    AddMessage("Please contact an administrator.", "text-warning");
                    return;
                }
                
                // At this point currentRoom/currentRoomId should be resolved. Render welcome + description and subscribe.
                if (currentRoom != null)
                {
                    AddMessage($"Welcome to {currentRoom.Zone.Name}!", "text-success");
                    AddMessage("Type 'look' to examine your surroundings.", "text-muted");

                    var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoom.Id);
                    AddMessage(roomDescription, "text-info");
                }
                else
                {
                    AddMessage("Welcome to Mordecai MUD!", "text-success");
                    AddMessage("Error: Unable to determine your location.", "text-danger");
                }
            }
            else
            {
                characterName = "(Invalid Character)";
                AddMessage("Error: Unable to load character data.", "text-danger");
                return;
            }
        }

        // Subscribe to messages for this character
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            MessageBroadcastService.MessageReceived += OnMessageReceived;
            await MessageBroadcastService.RegisterCharacterListenerAsync(
                characterId.Value,
                currentRoomId,
                characterName,
                currentUserName,
                currentUserId);
            isSubscribed = true;
            _logger?.LogDebug("Play: Registered message listener for character {CharacterId} in room {RoomId}", characterId, currentRoomId);
        }

        _logger?.LogDebug("Play.OnInitializedAsync end - characterId={CharacterId} roomId={RoomId}", characterId, currentRoomId);

        // Announce player joining
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            var joinMessage = new PlayerJoined(characterId.Value, characterName, currentRoomId.Value);
            await MessagePublisher.PublishAsync(joinMessage);
        }

        if (characterId.HasValue)
        {
            StartHealthRefreshLoop();
        }

        StateHasChanged();
    }

    private void ApplyHealthSnapshot(CharacterHealthSnapshot snapshot)
    {
        currentFat = snapshot.CurrentFatigue;
        maxFat = snapshot.MaxFatigue;
        pendingFat = snapshot.PendingFatigueDamage;
        currentVit = snapshot.CurrentVitality;
        maxVit = snapshot.MaxVitality;
        pendingVit = snapshot.PendingVitalityDamage;
    }

    private static string FormatPendingChange(int pending)
    {
        if (pending == 0)
        {
            return "0";
        }

        var displayed = -pending;
        return $"{(displayed > 0 ? "+" : string.Empty)}{displayed}";
    }

    private async Task RefreshCharacterVitalsAsync()
    {
        if (!characterId.HasValue)
        {
            return;
        }

        try
        {
            var snapshot = await CharacterService.GetCharacterHealthAsync(characterId.Value, currentUserId);
            if (snapshot != null)
            {
                ApplyHealthSnapshot(snapshot);
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error refreshing vitals for character {CharacterId}", characterId);
        }
    }

    private async Task LoadActiveEffects()
    {
        // TODO: Implement actual active effects loading from your character service
        // This is placeholder data
        activeEffects = new List<ActiveEffect>();
        
        await Task.CompletedTask;
    }

    // We avoid OnAfterRenderAsync for room resolution; rely on data-binding and StateHasChanged in OnInitializedAsync.

    private void OnMessageReceived(Guid targetCharacterId, string message)
    {
        // Only handle messages for this character
        if (targetCharacterId == characterId)
        {
            InvokeAsync(() =>
            {
                AddMessage(message, "text-light");
            });
        }
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(50); // Small delay to ensure DOM is updated
        await JSRuntime.InvokeVoidAsync("scrollToBottom", gameOutputElement);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendCommand();
        }
        else if (e.Key == "ArrowUp")
        {
            NavigateHistory(-1);
        }
        else if (e.Key == "ArrowDown")
        {
            NavigateHistory(1);
        }
    }

    private void NavigateHistory(int direction)
    {
        if (commandHistory.Count == 0) return;

        historyIndex += direction;
        if (historyIndex < 0) historyIndex = 0;
        if (historyIndex >= commandHistory.Count) historyIndex = commandHistory.Count - 1;

        if (historyIndex >= 0 && historyIndex < commandHistory.Count)
        {
            currentCommand = commandHistory[historyIndex];
            StateHasChanged();
        }
    }

    private async Task SendCommand()
    {
        if (string.IsNullOrWhiteSpace(currentCommand) || isProcessing || !characterId.HasValue)
            return;

        isProcessing = true;
        var command = currentCommand.Trim();
        
        // Add to history
        if (!string.IsNullOrEmpty(command))
        {
            commandHistory.Add(command);
            if (commandHistory.Count > 50) // Limit history size
            {
                commandHistory.RemoveAt(0);
            }
            historyIndex = commandHistory.Count;
        }

        // Display the command
        AddMessage($"> {command}", "text-warning");

        // Process the command
        await ProcessGameCommand(command);
    await RefreshCharacterVitalsAsync();

        currentCommand = string.Empty;
        isProcessing = false;
        
    // Request focus restoration after processing
    StateHasChanged();
    }

    private void ExitGame()
    {
        // Announce player leaving if they're in the game
        if (characterId.HasValue && currentRoomId.HasValue)
        {
            var disconnectMessage = new PlayerDisconnected(characterId.Value, characterName, currentRoomId.Value);
            _ = MessagePublisher.PublishAsync(disconnectMessage);
        }
        
        // Navigate back to character selection
        NavigationManager.NavigateTo("/characters");
    }

    private async Task ProcessGameCommand(string command)
    {
        if (!characterId.HasValue || !currentRoomId.HasValue || currentRoom == null) 
        {
            AddMessage("Error: Character or room data not properly loaded.", "text-danger");
            return;
        }

        // Simulate processing delay
        await Task.Delay(100);

        var cmd = command.ToLower().Trim();
        var parts = command.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var firstWord = parts.Length > 0 ? parts[0].ToLower() : "";
        
        try
        {
            switch (firstWord)
            {
                case "look":
                case "l":
                case "examine":
                case "ex":
                    if (parts.Length > 1)
                    {
                        // Look at a specific direction
                        var direction = parts[1].ToLower();
                        await HandleLookDirectionCommand(direction);
                    }
                    else
                    {
                        // Look around the room
                        var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoom.Id);
                        AddMessage(roomDescription, "text-success");
                    }
                    break;

                case "search":
                    await HandleSearchCommand();
                    break;

                case "skills":
                    await HandleSkillsCommand();
                    break;

                case "drive":
                    await HandleDriveCommand();
                    break;
                    
                case "help":
                    AddMessage("Available Commands:", "text-info");
                    AddMessage("look/l/examine/ex - Examine your surroundings");
                    AddMessage("look/l/examine/ex [direction] - Look in a specific direction (e.g., 'look north')");
                    AddMessage("search - Search for hidden things using your awareness skill (costs 1 FAT)");
                    AddMessage("skills - Display your character's skills and progress");
                    AddMessage("drive - Trade a portion of your vitality for fatigue recovery using the Drive skill");
                    AddMessage("say [message] - Speak to everyone in the room");
                    AddMessage("say [target] [message] - Speak to a specific character, NPC, or mob");
                    AddMessage("whisper [target] [message] - Whisper quietly to someone in the room");
                    AddMessage("tell [target] [message] - Speak privately to someone in the room");
                    AddMessage("yell|shout [message] - Raise your voice so nearby rooms hear you");
                    AddMessage("ooc [message] - Speak on the out-of-character channel");
                    AddMessage("emote [action] - Perform an emotive action");
                    AddMessage("who - See who else is online");
                    AddMessage("targets - List all possible targets in the room");
                    AddMessage("north/n, south/s, east/e, west/w - Move in those directions");
                    AddMessage("northeast/ne, northwest/nw, southeast/se, southwest/sw - Move diagonally");
                    AddMessage("up/u, down/d, in, out - Move vertically or through openings");
                    AddMessage("quit - Leave the game");
                    break;
                    
                case "who":
                    var activePlayers = MessageBroadcastService
                        .GetActiveCharacters()
                        .OrderBy(info => info.CharacterName, StringComparer.OrdinalIgnoreCase)
                        .ToList();

                    if (activePlayers.Count == 0)
                    {
                        AddMessage("No players are currently online.", "text-muted");
                        break;
                    }

                    AddMessage("Players currently online:", "text-info");

                    foreach (var player in activePlayers)
                    {
                        var isSelf = characterId.HasValue && player.CharacterId == characterId.Value;
                        var line = $"  {player.CharacterName}";

                        if (isSelf)
                        {
                            line += " (you)";
                        }

                        if (isCurrentUserAdmin && !string.IsNullOrWhiteSpace(player.UserDisplayName))
                        {
                            line += " - ";
                            line += player.UserDisplayName;
                        }

                        AddMessage(line);
                    }

                    var totalPlayers = activePlayers.Count;
                    AddMessage($"{totalPlayers} player{(totalPlayers == 1 ? string.Empty : "s")} total.");
                    break;
                    
                case "quit":
                    AddMessage("Thank you for playing Mordecai MUD!", "text-success");
                    AddMessage("Your progress has been saved.");
                    
                    // Announce player leaving
                    var disconnectMessage = new PlayerDisconnected(characterId.Value, characterName, currentRoomId.Value);
                    await MessagePublisher.PublishAsync(disconnectMessage);
                    break;
                    
                case "north": case "n":
                case "south": case "s":
                case "east": case "e":
                case "west": case "w":
                case "northeast": case "ne":
                case "northwest": case "nw":
                case "southeast": case "se":
                case "southwest": case "sw":
                case "up": case "u":
                case "down": case "d":
                case "in":
                case "out":
                    await HandleMovementCommand(cmd);
                    break;
                    
                case "targets":
                    var targets = await GameActionService.GetAvailableTargetsAsync(currentRoomId.Value, characterId);
                    if (targets.Any())
                    {
                        AddMessage("Available targets in this room:", "text-info");
                        foreach (var target in targets)
                        {
                            var typeDescription = target.Type switch
                            {
                                Mordecai.Messaging.Messages.TargetType.Character => "character",
                                Mordecai.Messaging.Messages.TargetType.Npc => "NPC",
                                Mordecai.Messaging.Messages.TargetType.Mob => "mob",
                                _ => "unknown"
                            };
                            var onlineStatus = target.IsOnline ? "" : " (offline)";
                            AddMessage($"  {target.Name} ({typeDescription}){onlineStatus}");
                        }
                    }
                    else
                    {
                        AddMessage("There are no other targets in this room.", "text-muted");
                    }
                    break;
                    
                default:
                    if (firstWord == "say")
                    {
                        await HandleSayCommand(parts);
                    }
                    else if (firstWord == "whisper")
                    {
                        await HandleWhisperCommand(parts);
                    }
                    else if (firstWord == "tell")
                    {
                        await HandleTellCommand(parts);
                    }
                    else if (firstWord == "yell" || firstWord == "shout")
                    {
                        await HandleYellCommand(parts);
                    }
                    else if (firstWord == "ooc" && parts.Length > 1)
                    {
                        await HandleOocCommand(parts);
                    }
                    else if (firstWord == "emote" && parts.Length > 1)
                    {
                        await HandleEmoteCommand(parts);
                    }
                    else
                    {
                        AddMessage($"Unknown command: '{command}'. Type 'help' for available commands.", "text-danger");
                    }
                    break;
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error processing command: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleDriveCommand()
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        try
        {
            var result = await CharacterService.TryPerformDriveConversionAsync(characterId.Value, currentUserId);

            if (!string.IsNullOrWhiteSpace(result.Feedback))
            {
                var feedbackClass = result.Success
                    ? "text-success"
                    : (!result.DiceRoll.HasValue && result.AbilityScore == 0 ? "text-danger" : "text-warning");
                AddMessage(result.Feedback, feedbackClass);
            }

            if (result.DiceRoll.HasValue && result.CheckTotal.HasValue)
            {
                AddMessage($"Drive check: AS {result.AbilityScore} {result.DiceRoll.Value:+0;-0;0} (4dF+) = {result.CheckTotal.Value} vs TV {result.TargetValue}.", "text-muted");
            }
            else if (result.AbilityScore > 0)
            {
                AddMessage($"Drive ability score {result.AbilityScore} vs TV {result.TargetValue}.", "text-muted");
            }

            if (result.Success)
            {
                AddMessage($"Pending health updated: +{result.VitalityDamageAmount} VIT damage, -{result.FatigueHealingAmount} FAT.", "text-info");
            }

            if (result.Snapshot != null)
            {
                ApplyHealthSnapshot(result.Snapshot);
            }
        }
        catch (Exception ex)
        {
            AddMessage($"Error performing Drive conversion: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleSearchCommand()
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        if (!currentRoomId.HasValue)
        {
            AddMessage("You are not currently in a room to search.", "text-danger");
            return;
        }

        var activeCharacterId = characterId.Value;
        var currentRoomIdValue = currentRoomId.Value;

        try
        {
            var awarenessSkillId = await GetAwarenessSkillIdAsync();
            if (awarenessSkillId == null)
            {
                AddMessage("Your character doesn't seem to have developed awareness yet.", "text-warning");
                return;
            }

            var awarenessSkill = await SkillService.GetCharacterSkillAsync(activeCharacterId, awarenessSkillId.Value);

            if (awarenessSkill == null)
            {
                AddMessage("You don't seem to have developed your awareness skill yet.", "text-warning");
                return;
            }

            var character = await CharacterService.GetCharacterByIdAsync(activeCharacterId, currentUserId);
            if (character is null)
            {
                AddMessage("Unable to load your character data for this action.", "text-danger");
                return;
            }

            var fatigueResult = await CharacterService.TryConsumeFatigueAsync(activeCharacterId, currentUserId, 1, "You are too exhausted to search.");
            if (!fatigueResult.Success)
            {
                if (!string.IsNullOrWhiteSpace(fatigueResult.FailureReason))
                {
                    AddMessage(fatigueResult.FailureReason, "text-danger");
                }

                if (fatigueResult.Snapshot != null)
                {
                    ApplyHealthSnapshot(fatigueResult.Snapshot);
                }

                return;
            }

            if (fatigueResult.Snapshot != null)
            {
                ApplyHealthSnapshot(fatigueResult.Snapshot);
            }

            AddMessage("You carefully search the area for hidden things...", "text-info");

            using var diceService = new DiceService();
            var abilityScore = awarenessSkill.CalculateAbilityScore(character);
            var diceRoll = diceService.RollExploding4dF();
            var skillCheck = abilityScore + diceRoll;
            AddMessage($"Awareness check: {abilityScore} (AS) {diceRoll:+0;-0;0} (4dF+) = {skillCheck}", "text-muted");

            var searchOutcome = await PerformRoomSearch(skillCheck);

            var usageType = diceRoll >= 4
                ? Mordecai.Web.Data.SkillUsageType.CriticalSuccess
                : searchOutcome.FoundHiddenExit
                    ? Mordecai.Web.Data.SkillUsageType.ChallengingUse
                    : Mordecai.Web.Data.SkillUsageType.RoutineUse;
            var didAdvance = await SkillService.AddSkillUsageAsync(
                activeCharacterId,
                awarenessSkillId.Value,
                usageType,
                baseUsagePoints: 1,
                context: "Room Search",
                details: $"Skill check result: {skillCheck} (AS {abilityScore}, roll {diceRoll:+0;-0;0})"
            );

            if (searchOutcome.Discoveries.Any())
            {
                AddMessage("Your search reveals:", "text-success");
                foreach (var thing in searchOutcome.Discoveries)
                {
                    AddMessage($"  {thing}", "text-warning");
                }
            }
            else
            {
                AddMessage("You don't find anything hidden here.", "text-muted");
            }

            if (searchOutcome.HiddenExitsPresent && !searchOutcome.FoundHiddenExit)
            {
                AddMessage("Something about this place still feels concealed, but you can't pinpoint it yet.", "text-muted");
            }

            if (didAdvance)
            {
                var newSkill = await SkillService.GetCharacterSkillAsync(activeCharacterId, awarenessSkillId.Value);
                AddMessage($"Your awareness skill has improved to level {newSkill?.Level}!", "text-success");
            }

            var searchMessage = new EmoteMessage(activeCharacterId, characterName, currentRoomIdValue, "searches the area carefully");
            await MessagePublisher.PublishAsync(searchMessage);
        }
        catch (Exception ex)
        {
            AddMessage($"Error performing search: {ex.Message}", "text-danger");
        }
    }

    private const int DefaultHiddenExitTargetScore = 10;

    private sealed record RoomSearchResult(
        List<string> Discoveries,
        bool FoundHiddenExit,
        bool HiddenExitsPresent,
        int HighestTargetValue);

    private async Task<RoomSearchResult> PerformRoomSearch(int skillCheckResult)
    {
        var foundThings = new List<string>();

        var hiddenExits = await WorldService.GetHiddenExitsFromRoomAsync(currentRoomId!.Value);

        var hiddenExitsPresent = false;
        var foundHiddenExit = false;
        var highestTarget = 0;

        foreach (var exit in hiddenExits)
        {
            hiddenExitsPresent = true;

            var targetScore = exit.HiddenTargetScore > 0 ? exit.HiddenTargetScore : DefaultHiddenExitTargetScore;
            var skillRequirementPenalty = exit.SkillRequired.HasValue
                ? (int)Math.Ceiling(exit.SkillLevelRequired)
                : 0;
            var difficulty = targetScore + skillRequirementPenalty;
            highestTarget = Math.Max(highestTarget, difficulty);

            if (skillCheckResult >= difficulty)
            {
                foundHiddenExit = true;
                var description = exit.GetExitDescription() ?? $"a hidden passage {exit.Direction}";
                foundThings.Add($"A hidden exit {exit.Direction}: {description}");
            }
        }

        if (skillCheckResult >= 15)
        {
            foundThings.Add("subtle wear patterns on the floor suggesting hidden activity");
        }

        if (skillCheckResult >= 18)
        {
            foundThings.Add("faint scratch marks near what might be a concealed mechanism");
        }

        return new RoomSearchResult(foundThings, foundHiddenExit, hiddenExitsPresent, hiddenExitsPresent ? highestTarget : 0);
    }

    private async Task<int?> GetAwarenessSkillIdAsync()
    {
        try
        {
            // Look up the Awareness skill definition from the seeded data
            var skillCategories = await SkillService.GetSkillCategoriesAsync();
            var coreSkillsCategory = skillCategories.FirstOrDefault(c => c.Name == "Core Skills");
            if (coreSkillsCategory == null)
            {
                return null;
            }

            var awarenessSkill = coreSkillsCategory.Skills.FirstOrDefault(s => s.Name == "Awareness");
            return awarenessSkill?.Id;
        }
        catch (Exception ex)
        {
            AddMessage($"Error finding awareness skill: {ex.Message}", "text-danger");
            return null;
        }
    }

    private async Task HandleSkillsCommand()
    {
        try
        {
            AddMessage("=== Your Character Skills ===", "text-info");
            
            // Get all character skills organized by category
            var characterSkills = await SkillService.GetCharacterSkillsAsync(characterId!.Value);
            
            if (!characterSkills.Any())
            {
                AddMessage("You haven't developed any skills yet.", "text-warning");
                AddMessage("This shouldn't happen for properly initialized characters.", "text-muted");
                AddMessage("Try creating a new character or contact an administrator.", "text-muted");
                return;
            }

            // Group skills by category for organized display
            var skillsByCategory = characterSkills
                .GroupBy(cs => cs.SkillDefinition.Category.Name)
                .OrderBy(g => g.First().SkillDefinition.Category.DisplayOrder);

            foreach (var categoryGroup in skillsByCategory)
            {
                // Display category name
                AddMessage($"\n--- {categoryGroup.Key} ---", "text-warning");
                
                var skillsInCategory = categoryGroup
                    .OrderBy(cs => cs.SkillDefinition.DisplayOrder)
                    .ThenBy(cs => cs.SkillDefinition.Name);

                foreach (var characterSkill in skillsInCategory)
                {
                    var skill = characterSkill.SkillDefinition;
                    var currentLevel = characterSkill.Level;
                    var totalUsage = characterSkill.Experience;
                    var usageCount = characterSkill.UsageCount;
                    
                    // Calculate progress to next level (not the final level)
                    var usageForCurrentLevel = skill.CalculateTotalUsageForLevel(currentLevel);
                    var usageForNextLevel = skill.CalculateTotalUsageForLevel(currentLevel + 1);
                    var progressPoints = totalUsage - usageForCurrentLevel;
                    var requiredPointsForNextLevel = usageForNextLevel - usageForCurrentLevel;
                    var progressPercent = requiredPointsForNextLevel > 0 ? (progressPoints * 100.0m / requiredPointsForNextLevel) : 100.0m;
                    
                    // Create progress bar visualization
                    var progressBarLength = 20;
                    var filledBars = (int)(progressPercent / 100.0m * progressBarLength);
                    var progressBar = new string('?', filledBars) + new string('?', progressBarLength - filledBars);
                    
                    // Format the skill line
                    var skillLine = $"{skill.Name,-18} Level {currentLevel,2} [{progressBar}] {progressPercent:F1}%";
                    AddMessage($"  {skillLine}", "text-light");
                    
                    // Add usage information for detailed tracking - show progress to NEXT level, not final level
                    var usageInfo = $"    Usage: {progressPoints}/{requiredPointsForNextLevel} points ({usageCount} total uses)";
                    AddMessage(usageInfo, "text-muted");
                    
                    // Show last used information if available
                    if (characterSkill.LastUsedAt.HasValue)
                    {
                        var timeSinceLastUse = DateTimeOffset.UtcNow - characterSkill.LastUsedAt.Value;
                        var lastUsedText = timeSinceLastUse.TotalDays >= 1 
                            ? $"{timeSinceLastUse.Days} days ago"
                            : timeSinceLastUse.TotalHours >= 1 
                                ? $"{timeSinceLastUse.Hours} hours ago"
                                : "Recently";
                        AddMessage($"    Last used: {lastUsedText}", "text-muted");
                    }
                }
            }
            
            // Add summary statistics
            var totalSkills = characterSkills.Count;
            var averageLevel = characterSkills.Average(cs => cs.Level);
            var totalUsages = characterSkills.Sum(cs => cs.UsageCount);
            
            AddMessage($"\nSkill Summary:", "text-info");
            AddMessage($"  Total Skills: {totalSkills}", "text-light");
            AddMessage($"  Average Level: {averageLevel:F1}", "text-light");
            AddMessage($"  Total Skill Uses: {totalUsages:N0}", "text-light");
            
            // Show highest skill
            var highestSkill = characterSkills.OrderByDescending(cs => cs.Level).First();
            AddMessage($"  Highest Skill: {highestSkill.SkillDefinition.Name} (Level {highestSkill.Level})", "text-success");
            
            // Show available skill categories that the character doesn't have skills in yet
            var allCategories = await SkillService.GetSkillCategoriesAsync();
            var characterSkillCategoryNames = skillsByCategory.Select(g => g.Key).ToHashSet();
            var unusedCategories = allCategories
                .Where(c => !characterSkillCategoryNames.Contains(c.Name))
                .OrderBy(c => c.DisplayOrder)
                .ToList();
            
            if (unusedCategories.Any())
            {
                AddMessage($"\nSkill Categories Available for Learning:", "text-info");
                foreach (var category in unusedCategories)
                {
                    var skillCount = category.Skills.Count(s => s.IsActive && !s.IsStartingSkill);
                    if (skillCount > 0)
                    {
                        AddMessage($"  {category.Name}: {skillCount} skills available", "text-muted");
                    }
                }
                AddMessage("  (Skills in these categories can be learned through practice or training)", "text-muted");
            }
            
        }
        catch (Exception ex)
        {
            AddMessage($"Error displaying skills: {ex.Message}", "text-danger");
        }
    }

    private async Task HandleMovementCommand(string direction)
    {
        if (!characterId.HasValue)
        {
            AddMessage("Character not loaded.", "text-danger");
            return;
        }

        // Normalize direction
        var normalizedDirection = direction switch
        {
            "n" => "north",
            "s" => "south", 
            "e" => "east",
            "w" => "west",
            "ne" => "northeast",
            "nw" => "northwest",
            "se" => "southeast",
            "sw" => "southwest",
            "u" => "up",
            "d" => "down",
            _ => direction
        };

        // Fetch exit details to evaluate traversal rules
        var exit = await WorldService.GetExitFromRoomAsync(currentRoomId!.Value, normalizedDirection);
        if (exit == null)
        {
            AddMessage("You cannot go that way.", "text-danger");
            return;
        }

        if (exit.IsDoorClosed)
        {
            var doorLabel = exit.GetDoorDisplayName();
            AddMessage($"The {doorLabel} to the {normalizedDirection} is closed.", "text-warning");
            return;
        }

        var destinationRoom = exit.ToRoom ?? await WorldService.GetRoomByExitAsync(currentRoomId.Value, normalizedDirection);
        if (destinationRoom == null)
        {
            AddMessage("That exit seems to lead nowhere.", "text-danger");
            return;
        }

        var fatigueResult = await CharacterService.TryConsumeFatigueAsync(characterId.Value, currentUserId, 1, "You are too exhausted to move.");
        if (!fatigueResult.Success)
        {
            if (!string.IsNullOrWhiteSpace(fatigueResult.FailureReason))
            {
                AddMessage(fatigueResult.FailureReason, "text-danger");
            }

            if (fatigueResult.Snapshot != null)
            {
                ApplyHealthSnapshot(fatigueResult.Snapshot);
            }

            return;
        }

        if (fatigueResult.Snapshot != null)
        {
            ApplyHealthSnapshot(fatigueResult.Snapshot);
        }

        // Announce leaving current room
        var leftMessage = new PlayerLeft(characterId!.Value, characterName, currentRoomId.Value, normalizedDirection);
        await MessagePublisher.PublishAsync(leftMessage);

        // Update current room
        var oldRoomId = currentRoomId.Value;
        currentRoomId = destinationRoom.Id;
        currentRoom = destinationRoom;

        // Update character's room in the database (when CurrentRoomId field is added)
        await CharacterService.SetCharacterRoomAsync(characterId.Value, currentUserId, currentRoomId.Value);

        // Update message subscription
        MessageBroadcastService.UpdateCharacterRoom(characterId.Value, currentRoomId);

        // Announce arriving in new room
        var movedMessage = new PlayerMoved(characterId.Value, characterName, oldRoomId, currentRoomId.Value, normalizedDirection);
        await MessagePublisher.PublishAsync(movedMessage);

        // Show movement and new room description
        AddMessage($"You go {normalizedDirection}.", "text-info");
        var roomDescription = await WorldService.GetRoomDescriptionAsync(currentRoomId.Value);
        AddMessage(roomDescription, "text-success");
    }

    private async Task HandleSayCommand(string[] parts)
    {
        string? targetName = null;
        string message;
        
        // Check if this might be a targeted say command
        if (parts.Length > 2)
        {
            // Try to parse as "say [target] [message]"
            var potentialTarget = parts[1];
            var remainingMessage = string.Join(" ", parts.Skip(2));
            
            // Check if the potential target exists
            var availableTargets = await GameActionService.GetAvailableTargetsAsync(currentRoomId!.Value, characterId);
            var foundTarget = availableTargets.FirstOrDefault(t => 
                t.Name.Equals(potentialTarget, StringComparison.OrdinalIgnoreCase) ||
                t.Name.ToLowerInvariant().StartsWith(potentialTarget.ToLowerInvariant()));
            
            if (foundTarget != null)
            {
                targetName = potentialTarget;
                message = remainingMessage;
            }
            else
            {
                // Not a valid target, treat as regular say with full message
                message = string.Join(" ", parts.Skip(1));
            }
        }
        else
        {
            // Regular say command
            message = string.Join(" ", parts.Skip(1));
        }

        if (!string.IsNullOrEmpty(message))
        {
            var result = await GameActionService.HandleChatMessageAsync(
                characterId!.Value, 
                characterName, 
                currentRoomId!.Value, 
                message, 
                ChatType.Say, 
                targetName);
            
            AddMessage(result, "text-success");
        }
        else
        {
            AddMessage("Say what?", "text-warning");
        }
    }

    private async Task HandleWhisperCommand(string[] parts)
    {
        if (parts.Length < 3)
        {
            AddMessage("Usage: whisper <target> <message>", "text-warning");
            return;
        }

        var targetName = parts[1];
        var message = string.Join(" ", parts.Skip(2));

        if (string.IsNullOrWhiteSpace(message))
        {
            AddMessage("Whisper what?", "text-warning");
            return;
        }

        var result = await GameActionService.HandleChatMessageAsync(
            characterId!.Value,
            characterName,
            currentRoomId!.Value,
            message,
            ChatType.Whisper,
            targetName);

        AddMessage(result, "text-success");
    }

    private async Task HandleTellCommand(string[] parts)
    {
        if (parts.Length < 3)
        {
            AddMessage("Usage: tell <target> <message>", "text-warning");
            return;
        }

        var targetName = parts[1];
        var message = string.Join(" ", parts.Skip(2));

        if (string.IsNullOrWhiteSpace(message))
        {
            AddMessage("Tell them what?", "text-warning");
            return;
        }

        var result = await GameActionService.HandleChatMessageAsync(
            characterId!.Value,
            characterName,
            currentRoomId!.Value,
            message,
            ChatType.Tell,
            targetName);

        AddMessage(result, "text-success");
    }

    private async Task HandleYellCommand(string[] parts)
    {
        var message = string.Join(" ", parts.Skip(1));

        if (string.IsNullOrWhiteSpace(message))
        {
            AddMessage("Yell what?", "text-warning");
            return;
        }

        var result = await GameActionService.HandleChatMessageAsync(
            characterId!.Value,
            characterName,
            currentRoomId!.Value,
            message,
            ChatType.Yell);

        AddMessage(result, "text-success");
    }

    private async Task HandleOocCommand(string[] parts)
    {
        var message = string.Join(" ", parts.Skip(1));
        if (!string.IsNullOrEmpty(message))
        {
            var globalChatMessage = new GlobalChatMessage(characterId!.Value, characterName, message, "ooc");
            await MessagePublisher.PublishAsync(globalChatMessage);
            
            AddMessage($"[OOC] You: {message}", "text-info");
        }
        else
        {
            AddMessage("Say what on OOC?", "text-warning");
        }
    }

    private async Task HandleEmoteCommand(string[] parts)
    {
        var emoteText = string.Join(" ", parts.Skip(1));
        if (!string.IsNullOrEmpty(emoteText))
        {
            var emoteMessage = new EmoteMessage(characterId!.Value, characterName, currentRoomId!.Value, emoteText);
            await MessagePublisher.PublishAsync(emoteMessage);
            
            AddMessage($"{characterName} {emoteText}.", "text-cyan");
        }
        else
        {
            AddMessage("Emote what?", "text-warning");
        }
    }

    private async Task HandleLookDirectionCommand(string direction)
    {
        // Normalize direction like movement commands
        var normalizedDirection = direction switch
        {
            "n" => "north",
            "s" => "south",
            "e" => "east",
            "w" => "west",
            "ne" => "northeast",
            "nw" => "northwest",
            "se" => "southeast",
            "sw" => "southwest",
            "u" => "up",
            "d" => "down",
            _ => direction
        };

        // Get the exit in that direction
        var exit = await WorldService.GetExitFromRoomAsync(currentRoomId!.Value, normalizedDirection);
        
        if (exit == null)
        {
            AddMessage($"You see nothing of interest to the {normalizedDirection}.", "text-muted");
            return;
        }

        if (exit.IsDoorClosed)
        {
            var doorLabel = exit.GetDoorDisplayName();
            AddMessage($"The {doorLabel} to the {normalizedDirection} is closed; you cannot see through it.", "text-warning");
            return;
        }

        // Build description for what they see in that direction
        var description = new List<string>();
        
        // Add exit description if available
        var exitDesc = exit.GetExitDescription(); // TODO: Pass isNight when time system is implemented
        if (!string.IsNullOrEmpty(exitDesc))
        {
            description.Add($"To the {normalizedDirection}, you see {exitDesc}.");
        }
        else
        {
            description.Add($"To the {normalizedDirection}, you can go to {exit.ToRoom.Name}.");
        }

        // Add destination room peek if not hidden
        if (!exit.IsHidden)
        {
            description.Add($"That direction leads to {exit.ToRoom.Name} in {exit.ToRoom.Zone.Name}.");
            
            // Add a brief peek at the destination room description (first sentence)
            var destinationDesc = exit.ToRoom.GetDescription(); // TODO: Pass isNight when time system is implemented
            var firstSentence = destinationDesc.Split('.', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
            if (!string.IsNullOrEmpty(firstSentence))
            {
                description.Add($"From here you can see: {firstSentence.Trim()}.");
            }
        }

        // Show any skill requirements
        if (exit.SkillRequired.HasValue && exit.SkillLevelRequired > 0)
        {
            description.Add($"This exit requires special skills to use (Skill Level {exit.SkillLevelRequired}).");
        }

        var finalDescription = string.Join(" ", description);
        AddMessage(finalDescription, "text-info");
    }

    private void AddMessage(string message, string cssClass = "")
    {
        var formattedMessage = !string.IsNullOrEmpty(cssClass) 
            ? $"<span class='{cssClass}'>{message}</span>" 
            : message;
        
        gameMessages.Add(formattedMessage);
        
        // Limit message history to prevent memory issues
        if (gameMessages.Count > 1000)
        {
            gameMessages.RemoveRange(0, 100);
        }
        
        // Scroll to bottom after adding message
        InvokeAsync(async () =>
        {
            StateHasChanged();
            await ScrollToBottom();
        });
    }

    public void Dispose()
    {
        if (isSubscribed && characterId.HasValue)
        {
            MessageBroadcastService.MessageReceived -= OnMessageReceived;
            _ = MessageBroadcastService.UnregisterCharacterListenerAsync(characterId.Value);
        }

        StopHealthRefreshLoop();
    }

    private void StartHealthRefreshLoop()
    {
        if (_healthRefreshTask != null)
        {
            return;
        }

        _healthRefreshCts = new CancellationTokenSource();
        var token = _healthRefreshCts.Token;

        _healthRefreshTask = Task.Run(async () =>
        {
            try
            {
                using var timer = new PeriodicTimer(HealthRefreshInterval);
                while (await timer.WaitForNextTickAsync(token))
                {
                    if (!characterId.HasValue)
                    {
                        continue;
                    }

                    try
                    {
                        var snapshot = await CharacterService.GetCharacterHealthAsync(characterId.Value, currentUserId);
                        if (snapshot != null)
                        {
                            await InvokeAsync(() =>
                            {
                                ApplyHealthSnapshot(snapshot);
                                StateHasChanged();
                            });
                        }
                    }
                    catch (OperationCanceledException)
                    {
                        break;
                    }
                    catch (Exception ex)
                    {
                        await InvokeAsync(() => _logger?.LogError(ex, "Error refreshing character vitals in periodic loop"));
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // Expected during shutdown
            }
        }, token);
    }

    private void StopHealthRefreshLoop()
    {
        try
        {
            _healthRefreshCts?.Cancel();
        }
        catch
        {
            // Ignored during disposal
        }
        finally
        {
            _healthRefreshCts?.Dispose();
            _healthRefreshCts = null;
            _healthRefreshTask = null;
        }
    }
}

<style>
    /* Override the normal layout structure for the play page */
    .play-page-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1000;
        background: #fff;
        display: flex;
        flex-direction: column;
    }
    
    .play-page-header {
        border-bottom: 1px solid #dee2e6;
        flex-shrink: 0;
        min-height: 50px;
    }
    
    .play-page-content {
        display: flex;
        flex: 1;
        min-height: 0;
    }
    
    .character-panel {
        width: 300px;
        border-right: 1px solid #dee2e6;
        max-height: 100%;
        overflow-y: auto;
        flex-shrink: 0;
    }
    
    .character-status {
        background: linear-gradient(135deg, #1a1a1a 0%, #2d3748 100%);
    }
    
    .character-header {
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.75rem;
    }
    
    .location-info {
        border-bottom: 1px solid #4a5568;
        padding-bottom: 0.75rem;
    }
    
    .vital-bar .progress {
        background-color: #2d3748;
        border: 1px solid #4a5568;
    }
    
    .effects-list {
        max-height: 200px;
        overflow-y: auto;
    }
    
    .effect-item {
        border-left: 3px solid #17a2b8;
    }
    
    .game-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 0;
    }
    
    .game-container {
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        height: 100%;
        max-height: 100%;
    }
    
    .game-output-container {
        overflow: hidden;
        min-height: 0; /* Important for flex child to shrink */
    }
    
    .game-output {
        font-family: 'Courier New', monospace;
        line-height: 1.4;
        white-space: pre-wrap;
        word-wrap: break-word;
        scroll-behavior: smooth;
        height: 100% !important;
        max-height: 100%;
        overflow-y: auto !important;
        overflow-x: hidden;
    }
    
    .game-output::-webkit-scrollbar {
        width: 8px;
    }
    
    .game-output::-webkit-scrollbar-track {
        background: #2d3748;
    }
    
    .game-output::-webkit-scrollbar-thumb {
        background: #4a5568;
        border-radius: 4px;
    }
    
    .game-output::-webkit-scrollbar-thumb:hover {
        background: #718096;
    }
    
    .game-message {
        max-width: 100%;
        word-break: break-word;
    }

    .text-cyan {
        color: #17a2b8 !important;
    }
    
    .game-input {
        flex-shrink: 0; /* Prevent the input area from shrinking */
    }
    
    /* Mobile adjustments */
    media (max-width: 767.98px) {
        .character-panel {
            display: none !important;
        }
        
        .game-container {
            border-radius: 0;
            border: none;
            height: 100vh;
        }
        
        .game-output {
            font-size: 12px;
        }
        
        .play-page-header {
            font-size: 0.9rem;
        }
        
        .play-page-header h6 {
            font-size: 0.9rem;
        }
    }
    
    /* Responsive character panel toggle for smaller screens */
    media (max-width: 991.98px) {
        .character-panel {
            position: fixed;
            top: 50px; /* Account for header */
            left: -100%;
            width: 300px;
            height: calc(100vh - 50px);
            z-index: 1050;
            transition: left 0.3s ease;
            border-right: 1px solid #dee2e6;
            background-color: #1a1a1a;
        }
        
        .character-panel.show {
            left: 0;
        }
    }
</style>

<script>
    window.scrollToBottom = (element) => {
        if (element) {
            // Use requestAnimationFrame to ensure scrolling happens after DOM updates
            requestAnimationFrame(() => {
                element.scrollTop = element.scrollHeight;
            });
        }
    };
</script>